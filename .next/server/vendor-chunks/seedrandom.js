/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/seedrandom";
exports.ids = ["vendor-chunks/seedrandom"];
exports.modules = {

/***/ "(ssr)/./node_modules/seedrandom/index.js":
/*!******************************************!*\
  !*** ./node_modules/seedrandom/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// A library of seedable RNGs implemented in Javascript.\n//\n// Usage:\n//\n// var seedrandom = require('seedrandom');\n// var random = seedrandom(1); // or any seed.\n// var x = random();       // 0 <= x < 1.  Every bit is random.\n// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.\n// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.\n// Period: ~2^116\n// Reported to pass all BigCrush tests.\n\nvar alea = __webpack_require__(/*! ./lib/alea */ \"(ssr)/./node_modules/seedrandom/lib/alea.js\");\n// xor128, a pure xor-shift generator by George Marsaglia.\n// Period: 2^128-1.\n// Reported to fail: MatrixRank and LinearComp.\nvar xor128 = __webpack_require__(/*! ./lib/xor128 */ \"(ssr)/./node_modules/seedrandom/lib/xor128.js\");\n// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.\n// Period: 2^192-2^32\n// Reported to fail: CollisionOver, SimpPoker, and LinearComp.\nvar xorwow = __webpack_require__(/*! ./lib/xorwow */ \"(ssr)/./node_modules/seedrandom/lib/xorwow.js\");\n// xorshift7, by François Panneton and Pierre L'ecuyer, takes\n// a different approach: it adds robustness by allowing more shifts\n// than Marsaglia's original three.  It is a 7-shift generator\n// with 256 bits, that passes BigCrush with no systmatic failures.\n// Period 2^256-1.\n// No systematic BigCrush failures reported.\nvar xorshift7 = __webpack_require__(/*! ./lib/xorshift7 */ \"(ssr)/./node_modules/seedrandom/lib/xorshift7.js\");\n// xor4096, by Richard Brent, is a 4096-bit xor-shift with a\n// very long period that also adds a Weyl generator. It also passes\n// BigCrush with no systematic failures.  Its long period may\n// be useful if you have many generators and need to avoid\n// collisions.\n// Period: 2^4128-2^32.\n// No systematic BigCrush failures reported.\nvar xor4096 = __webpack_require__(/*! ./lib/xor4096 */ \"(ssr)/./node_modules/seedrandom/lib/xor4096.js\");\n// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random\n// number generator derived from ChaCha, a modern stream cipher.\n// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf\n// Period: ~2^127\n// No systematic BigCrush failures reported.\nvar tychei = __webpack_require__(/*! ./lib/tychei */ \"(ssr)/./node_modules/seedrandom/lib/tychei.js\");\n// The original ARC4-based prng included in this library.\n// Period: ~2^1600\nvar sr = __webpack_require__(/*! ./seedrandom */ \"(ssr)/./node_modules/seedrandom/seedrandom.js\");\nsr.alea = alea;\nsr.xor128 = xor128;\nsr.xorwow = xorwow;\nsr.xorshift7 = xorshift7;\nsr.xor4096 = xor4096;\nsr.tychei = tychei;\nmodule.exports = sr;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSx3REFBd0Q7QUFDeEQsRUFBRTtBQUNGLFNBQVM7QUFDVCxFQUFFO0FBQ0YsMENBQTBDO0FBQzFDLDhDQUE4QztBQUM5QywrREFBK0Q7QUFDL0QsaUVBQWlFO0FBRWpFLG1FQUFtRTtBQUNuRSxpQkFBaUI7QUFDakIsdUNBQXVDOztBQUN2QyxJQUFJQSxPQUFPQyxtQkFBT0EsQ0FBQztBQUVuQiwwREFBMEQ7QUFDMUQsbUJBQW1CO0FBQ25CLCtDQUErQztBQUMvQyxJQUFJQyxTQUFTRCxtQkFBT0EsQ0FBQztBQUVyQixtRUFBbUU7QUFDbkUscUJBQXFCO0FBQ3JCLDhEQUE4RDtBQUM5RCxJQUFJRSxTQUFTRixtQkFBT0EsQ0FBQztBQUVyQiw2REFBNkQ7QUFDN0QsbUVBQW1FO0FBQ25FLDhEQUE4RDtBQUM5RCxrRUFBa0U7QUFDbEUsa0JBQWtCO0FBQ2xCLDRDQUE0QztBQUM1QyxJQUFJRyxZQUFZSCxtQkFBT0EsQ0FBQztBQUV4Qiw0REFBNEQ7QUFDNUQsbUVBQW1FO0FBQ25FLDZEQUE2RDtBQUM3RCwwREFBMEQ7QUFDMUQsY0FBYztBQUNkLHVCQUF1QjtBQUN2Qiw0Q0FBNEM7QUFDNUMsSUFBSUksVUFBVUosbUJBQU9BLENBQUM7QUFFdEIsdUVBQXVFO0FBQ3ZFLGdFQUFnRTtBQUNoRSxxREFBcUQ7QUFDckQsaUJBQWlCO0FBQ2pCLDRDQUE0QztBQUM1QyxJQUFJSyxTQUFTTCxtQkFBT0EsQ0FBQztBQUVyQix5REFBeUQ7QUFDekQsa0JBQWtCO0FBQ2xCLElBQUlNLEtBQUtOLG1CQUFPQSxDQUFDO0FBRWpCTSxHQUFHUCxJQUFJLEdBQUdBO0FBQ1ZPLEdBQUdMLE1BQU0sR0FBR0E7QUFDWkssR0FBR0osTUFBTSxHQUFHQTtBQUNaSSxHQUFHSCxTQUFTLEdBQUdBO0FBQ2ZHLEdBQUdGLE9BQU8sR0FBR0E7QUFDYkUsR0FBR0QsTUFBTSxHQUFHQTtBQUVaRSxPQUFPQyxPQUFPLEdBQUdGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veW9nYXBvc2VwZXJmZWN0Ly4vbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vaW5kZXguanM/NGU4MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBIGxpYnJhcnkgb2Ygc2VlZGFibGUgUk5HcyBpbXBsZW1lbnRlZCBpbiBKYXZhc2NyaXB0LlxuLy9cbi8vIFVzYWdlOlxuLy9cbi8vIHZhciBzZWVkcmFuZG9tID0gcmVxdWlyZSgnc2VlZHJhbmRvbScpO1xuLy8gdmFyIHJhbmRvbSA9IHNlZWRyYW5kb20oMSk7IC8vIG9yIGFueSBzZWVkLlxuLy8gdmFyIHggPSByYW5kb20oKTsgICAgICAgLy8gMCA8PSB4IDwgMS4gIEV2ZXJ5IGJpdCBpcyByYW5kb20uXG4vLyB2YXIgeCA9IHJhbmRvbS5xdWljaygpOyAvLyAwIDw9IHggPCAxLiAgMzIgYml0cyBvZiByYW5kb21uZXNzLlxuXG4vLyBhbGVhLCBhIDUzLWJpdCBtdWx0aXBseS13aXRoLWNhcnJ5IGdlbmVyYXRvciBieSBKb2hhbm5lcyBCYWFnw7hlLlxuLy8gUGVyaW9kOiB+Ml4xMTZcbi8vIFJlcG9ydGVkIHRvIHBhc3MgYWxsIEJpZ0NydXNoIHRlc3RzLlxudmFyIGFsZWEgPSByZXF1aXJlKCcuL2xpYi9hbGVhJyk7XG5cbi8vIHhvcjEyOCwgYSBwdXJlIHhvci1zaGlmdCBnZW5lcmF0b3IgYnkgR2VvcmdlIE1hcnNhZ2xpYS5cbi8vIFBlcmlvZDogMl4xMjgtMS5cbi8vIFJlcG9ydGVkIHRvIGZhaWw6IE1hdHJpeFJhbmsgYW5kIExpbmVhckNvbXAuXG52YXIgeG9yMTI4ID0gcmVxdWlyZSgnLi9saWIveG9yMTI4Jyk7XG5cbi8vIHhvcndvdywgR2VvcmdlIE1hcnNhZ2xpYSdzIDE2MC1iaXQgeG9yLXNoaWZ0IGNvbWJpbmVkIHBsdXMgd2V5bC5cbi8vIFBlcmlvZDogMl4xOTItMl4zMlxuLy8gUmVwb3J0ZWQgdG8gZmFpbDogQ29sbGlzaW9uT3ZlciwgU2ltcFBva2VyLCBhbmQgTGluZWFyQ29tcC5cbnZhciB4b3J3b3cgPSByZXF1aXJlKCcuL2xpYi94b3J3b3cnKTtcblxuLy8geG9yc2hpZnQ3LCBieSBGcmFuw6dvaXMgUGFubmV0b24gYW5kIFBpZXJyZSBMJ2VjdXllciwgdGFrZXNcbi8vIGEgZGlmZmVyZW50IGFwcHJvYWNoOiBpdCBhZGRzIHJvYnVzdG5lc3MgYnkgYWxsb3dpbmcgbW9yZSBzaGlmdHNcbi8vIHRoYW4gTWFyc2FnbGlhJ3Mgb3JpZ2luYWwgdGhyZWUuICBJdCBpcyBhIDctc2hpZnQgZ2VuZXJhdG9yXG4vLyB3aXRoIDI1NiBiaXRzLCB0aGF0IHBhc3NlcyBCaWdDcnVzaCB3aXRoIG5vIHN5c3RtYXRpYyBmYWlsdXJlcy5cbi8vIFBlcmlvZCAyXjI1Ni0xLlxuLy8gTm8gc3lzdGVtYXRpYyBCaWdDcnVzaCBmYWlsdXJlcyByZXBvcnRlZC5cbnZhciB4b3JzaGlmdDcgPSByZXF1aXJlKCcuL2xpYi94b3JzaGlmdDcnKTtcblxuLy8geG9yNDA5NiwgYnkgUmljaGFyZCBCcmVudCwgaXMgYSA0MDk2LWJpdCB4b3Itc2hpZnQgd2l0aCBhXG4vLyB2ZXJ5IGxvbmcgcGVyaW9kIHRoYXQgYWxzbyBhZGRzIGEgV2V5bCBnZW5lcmF0b3IuIEl0IGFsc28gcGFzc2VzXG4vLyBCaWdDcnVzaCB3aXRoIG5vIHN5c3RlbWF0aWMgZmFpbHVyZXMuICBJdHMgbG9uZyBwZXJpb2QgbWF5XG4vLyBiZSB1c2VmdWwgaWYgeW91IGhhdmUgbWFueSBnZW5lcmF0b3JzIGFuZCBuZWVkIHRvIGF2b2lkXG4vLyBjb2xsaXNpb25zLlxuLy8gUGVyaW9kOiAyXjQxMjgtMl4zMi5cbi8vIE5vIHN5c3RlbWF0aWMgQmlnQ3J1c2ggZmFpbHVyZXMgcmVwb3J0ZWQuXG52YXIgeG9yNDA5NiA9IHJlcXVpcmUoJy4vbGliL3hvcjQwOTYnKTtcblxuLy8gVHljaGUtaSwgYnkgU2FtdWVsIE5ldmVzIGFuZCBGaWxpcGUgQXJhdWpvLCBpcyBhIGJpdC1zaGlmdGluZyByYW5kb21cbi8vIG51bWJlciBnZW5lcmF0b3IgZGVyaXZlZCBmcm9tIENoYUNoYSwgYSBtb2Rlcm4gc3RyZWFtIGNpcGhlci5cbi8vIGh0dHBzOi8vZWRlbi5kZWkudWMucHQvfnNuZXZlcy9wdWJzLzIwMTEtc25mYTIucGRmXG4vLyBQZXJpb2Q6IH4yXjEyN1xuLy8gTm8gc3lzdGVtYXRpYyBCaWdDcnVzaCBmYWlsdXJlcyByZXBvcnRlZC5cbnZhciB0eWNoZWkgPSByZXF1aXJlKCcuL2xpYi90eWNoZWknKTtcblxuLy8gVGhlIG9yaWdpbmFsIEFSQzQtYmFzZWQgcHJuZyBpbmNsdWRlZCBpbiB0aGlzIGxpYnJhcnkuXG4vLyBQZXJpb2Q6IH4yXjE2MDBcbnZhciBzciA9IHJlcXVpcmUoJy4vc2VlZHJhbmRvbScpO1xuXG5zci5hbGVhID0gYWxlYTtcbnNyLnhvcjEyOCA9IHhvcjEyODtcbnNyLnhvcndvdyA9IHhvcndvdztcbnNyLnhvcnNoaWZ0NyA9IHhvcnNoaWZ0NztcbnNyLnhvcjQwOTYgPSB4b3I0MDk2O1xuc3IudHljaGVpID0gdHljaGVpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNyO1xuIl0sIm5hbWVzIjpbImFsZWEiLCJyZXF1aXJlIiwieG9yMTI4IiwieG9yd293IiwieG9yc2hpZnQ3IiwieG9yNDA5NiIsInR5Y2hlaSIsInNyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/seedrandom/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/seedrandom/lib/alea.js":
/*!*********************************************!*\
  !*** ./node_modules/seedrandom/lib/alea.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010\n// http://baagoe.com/en/RandomMusings/javascript/\n// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror\n// Original work is under MIT license -\n// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n(function(global, module1, define1) {\n    function Alea(seed) {\n        var me = this, mash = Mash();\n        me.next = function() {\n            var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32\n            me.s0 = me.s1;\n            me.s1 = me.s2;\n            return me.s2 = t - (me.c = t | 0);\n        };\n        // Apply the seeding algorithm from Baagoe.\n        me.c = 1;\n        me.s0 = mash(\" \");\n        me.s1 = mash(\" \");\n        me.s2 = mash(\" \");\n        me.s0 -= mash(seed);\n        if (me.s0 < 0) {\n            me.s0 += 1;\n        }\n        me.s1 -= mash(seed);\n        if (me.s1 < 0) {\n            me.s1 += 1;\n        }\n        me.s2 -= mash(seed);\n        if (me.s2 < 0) {\n            me.s2 += 1;\n        }\n        mash = null;\n    }\n    function copy(f, t) {\n        t.c = f.c;\n        t.s0 = f.s0;\n        t.s1 = f.s1;\n        t.s2 = f.s2;\n        return t;\n    }\n    function impl(seed, opts) {\n        var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;\n        prng.int32 = function() {\n            return xg.next() * 0x100000000 | 0;\n        };\n        prng.double = function() {\n            return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53\n        };\n        prng.quick = prng;\n        if (state) {\n            if (typeof state == \"object\") copy(state, xg);\n            prng.state = function() {\n                return copy(xg, {});\n            };\n        }\n        return prng;\n    }\n    function Mash() {\n        var n = 0xefc8249d;\n        var mash = function(data) {\n            data = String(data);\n            for(var i = 0; i < data.length; i++){\n                n += data.charCodeAt(i);\n                var h = 0.02519603282416938 * n;\n                n = h >>> 0;\n                h -= n;\n                h *= n;\n                n = h >>> 0;\n                h -= n;\n                n += h * 0x100000000; // 2^32\n            }\n            return (n >>> 0) * 2.3283064365386963e-10; // 2^-32\n        };\n        return mash;\n    }\n    if (module1 && module1.exports) {\n        module1.exports = impl;\n    } else if (__webpack_require__.amdD && __webpack_require__.amdO) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return impl;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {\n        this.alea = impl;\n    }\n})(this,  true && module, __webpack_require__.amdD // present with an AMD loader\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIvYWxlYS5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsd0dBQXNFO0FBQ3RFLGlEQUFpRDtBQUNqRCwwRUFBMEU7QUFDMUUsdUNBQXVDO0FBRXZDLDREQUE0RDtBQUM1RCxFQUFFO0FBQ0YsK0VBQStFO0FBQy9FLGdGQUFnRjtBQUNoRiwrRUFBK0U7QUFDL0UsNEVBQTRFO0FBQzVFLHdFQUF3RTtBQUN4RSwyREFBMkQ7QUFDM0QsRUFBRTtBQUNGLDZFQUE2RTtBQUM3RSxzREFBc0Q7QUFDdEQsRUFBRTtBQUNGLDZFQUE2RTtBQUM3RSwyRUFBMkU7QUFDM0UsOEVBQThFO0FBQzlFLHlFQUF5RTtBQUN6RSxnRkFBZ0Y7QUFDaEYsNEVBQTRFO0FBQzVFLGdCQUFnQjtBQUlmLFVBQVNBLE1BQU0sRUFBRUMsT0FBTSxFQUFFQyxPQUFNO0lBRWhDLFNBQVNDLEtBQUtDLElBQUk7UUFDaEIsSUFBSUMsS0FBSyxJQUFJLEVBQUVDLE9BQU9DO1FBRXRCRixHQUFHRyxJQUFJLEdBQUc7WUFDUixJQUFJQyxJQUFJLFVBQVVKLEdBQUdLLEVBQUUsR0FBR0wsR0FBR00sQ0FBQyxHQUFHLHdCQUF3QixRQUFRO1lBQ2pFTixHQUFHSyxFQUFFLEdBQUdMLEdBQUdPLEVBQUU7WUFDYlAsR0FBR08sRUFBRSxHQUFHUCxHQUFHUSxFQUFFO1lBQ2IsT0FBT1IsR0FBR1EsRUFBRSxHQUFHSixJQUFLSixDQUFBQSxHQUFHTSxDQUFDLEdBQUdGLElBQUk7UUFDakM7UUFFQSwyQ0FBMkM7UUFDM0NKLEdBQUdNLENBQUMsR0FBRztRQUNQTixHQUFHSyxFQUFFLEdBQUdKLEtBQUs7UUFDYkQsR0FBR08sRUFBRSxHQUFHTixLQUFLO1FBQ2JELEdBQUdRLEVBQUUsR0FBR1AsS0FBSztRQUNiRCxHQUFHSyxFQUFFLElBQUlKLEtBQUtGO1FBQ2QsSUFBSUMsR0FBR0ssRUFBRSxHQUFHLEdBQUc7WUFBRUwsR0FBR0ssRUFBRSxJQUFJO1FBQUc7UUFDN0JMLEdBQUdPLEVBQUUsSUFBSU4sS0FBS0Y7UUFDZCxJQUFJQyxHQUFHTyxFQUFFLEdBQUcsR0FBRztZQUFFUCxHQUFHTyxFQUFFLElBQUk7UUFBRztRQUM3QlAsR0FBR1EsRUFBRSxJQUFJUCxLQUFLRjtRQUNkLElBQUlDLEdBQUdRLEVBQUUsR0FBRyxHQUFHO1lBQUVSLEdBQUdRLEVBQUUsSUFBSTtRQUFHO1FBQzdCUCxPQUFPO0lBQ1Q7SUFFQSxTQUFTUSxLQUFLQyxDQUFDLEVBQUVOLENBQUM7UUFDaEJBLEVBQUVFLENBQUMsR0FBR0ksRUFBRUosQ0FBQztRQUNURixFQUFFQyxFQUFFLEdBQUdLLEVBQUVMLEVBQUU7UUFDWEQsRUFBRUcsRUFBRSxHQUFHRyxFQUFFSCxFQUFFO1FBQ1hILEVBQUVJLEVBQUUsR0FBR0UsRUFBRUYsRUFBRTtRQUNYLE9BQU9KO0lBQ1Q7SUFFQSxTQUFTTyxLQUFLWixJQUFJLEVBQUVhLElBQUk7UUFDdEIsSUFBSUMsS0FBSyxJQUFJZixLQUFLQyxPQUNkZSxRQUFRRixRQUFRQSxLQUFLRSxLQUFLLEVBQzFCQyxPQUFPRixHQUFHVixJQUFJO1FBQ2xCWSxLQUFLQyxLQUFLLEdBQUc7WUFBYSxPQUFPLEdBQUliLElBQUksS0FBSyxjQUFlO1FBQUc7UUFDaEVZLEtBQUtFLE1BQU0sR0FBRztZQUNaLE9BQU9GLFNBQVMsQ0FBQ0EsU0FBUyxXQUFXLEtBQUssd0JBQXdCLFFBQVE7UUFDNUU7UUFDQUEsS0FBS0csS0FBSyxHQUFHSDtRQUNiLElBQUlELE9BQU87WUFDVCxJQUFJLE9BQU9BLFNBQVUsVUFBVUwsS0FBS0ssT0FBT0Q7WUFDM0NFLEtBQUtELEtBQUssR0FBRztnQkFBYSxPQUFPTCxLQUFLSSxJQUFJLENBQUM7WUFBSTtRQUNqRDtRQUNBLE9BQU9FO0lBQ1Q7SUFFQSxTQUFTYjtRQUNQLElBQUlpQixJQUFJO1FBRVIsSUFBSWxCLE9BQU8sU0FBU21CLElBQUk7WUFDdEJBLE9BQU9DLE9BQU9EO1lBQ2QsSUFBSyxJQUFJRSxJQUFJLEdBQUdBLElBQUlGLEtBQUtHLE1BQU0sRUFBRUQsSUFBSztnQkFDcENILEtBQUtDLEtBQUtJLFVBQVUsQ0FBQ0Y7Z0JBQ3JCLElBQUlHLElBQUksc0JBQXNCTjtnQkFDOUJBLElBQUlNLE1BQU07Z0JBQ1ZBLEtBQUtOO2dCQUNMTSxLQUFLTjtnQkFDTEEsSUFBSU0sTUFBTTtnQkFDVkEsS0FBS047Z0JBQ0xBLEtBQUtNLElBQUksYUFBYSxPQUFPO1lBQy9CO1lBQ0EsT0FBTyxDQUFDTixNQUFNLEtBQUssd0JBQXdCLFFBQVE7UUFDckQ7UUFFQSxPQUFPbEI7SUFDVDtJQUdBLElBQUlMLFdBQVVBLFFBQU84QixPQUFPLEVBQUU7UUFDNUI5QixRQUFPOEIsT0FBTyxHQUFHZjtJQUNuQixPQUFPLElBQUlkLHdCQUFBQSxJQUFVQSx3QkFBVSxFQUFFO1FBQy9CQSxtQ0FBTztZQUFhLE9BQU9jO1FBQU0sQ0FBQztBQUFBLGtHQUFDO0lBQ3JDLE9BQU87UUFDTCxJQUFJLENBQUNpQixJQUFJLEdBQUdqQjtJQUNkO0FBRUEsR0FDRSxJQUFJLEVBQ0osS0FBbUIsSUFBWWYsUUFDL0Isd0JBQXVDQyxDQUFHLDZCQUE2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3lvZ2Fwb3NlcGVyZmVjdC8uL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi9hbGVhLmpzPzhiYWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQSBwb3J0IG9mIGFuIGFsZ29yaXRobSBieSBKb2hhbm5lcyBCYWFnw7hlIDxiYWFnb2VAYmFhZ29lLmNvbT4sIDIwMTBcbi8vIGh0dHA6Ly9iYWFnb2UuY29tL2VuL1JhbmRvbU11c2luZ3MvamF2YXNjcmlwdC9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ucXVpbmxhbi9iZXR0ZXItcmFuZG9tLW51bWJlcnMtZm9yLWphdmFzY3JpcHQtbWlycm9yXG4vLyBPcmlnaW5hbCB3b3JrIGlzIHVuZGVyIE1JVCBsaWNlbnNlIC1cblxuLy8gQ29weXJpZ2h0IChDKSAyMDEwIGJ5IEpvaGFubmVzIEJhYWfDuGUgPGJhYWdvZUBiYWFnb2Uub3JnPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cblxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBBbGVhKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgbWFzaCA9IE1hc2goKTtcblxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSAyMDkxNjM5ICogbWUuczAgKyBtZS5jICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcbiAgICBtZS5zMCA9IG1lLnMxO1xuICAgIG1lLnMxID0gbWUuczI7XG4gICAgcmV0dXJuIG1lLnMyID0gdCAtIChtZS5jID0gdCB8IDApO1xuICB9O1xuXG4gIC8vIEFwcGx5IHRoZSBzZWVkaW5nIGFsZ29yaXRobSBmcm9tIEJhYWdvZS5cbiAgbWUuYyA9IDE7XG4gIG1lLnMwID0gbWFzaCgnICcpO1xuICBtZS5zMSA9IG1hc2goJyAnKTtcbiAgbWUuczIgPSBtYXNoKCcgJyk7XG4gIG1lLnMwIC09IG1hc2goc2VlZCk7XG4gIGlmIChtZS5zMCA8IDApIHsgbWUuczAgKz0gMTsgfVxuICBtZS5zMSAtPSBtYXNoKHNlZWQpO1xuICBpZiAobWUuczEgPCAwKSB7IG1lLnMxICs9IDE7IH1cbiAgbWUuczIgLT0gbWFzaChzZWVkKTtcbiAgaWYgKG1lLnMyIDwgMCkgeyBtZS5zMiArPSAxOyB9XG4gIG1hc2ggPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC5jID0gZi5jO1xuICB0LnMwID0gZi5zMDtcbiAgdC5zMSA9IGYuczE7XG4gIHQuczIgPSBmLnMyO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBBbGVhKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0geGcubmV4dDtcbiAgcHJuZy5pbnQzMiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSAqIDB4MTAwMDAwMDAwKSB8IDA7IH1cbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcHJuZygpICsgKHBybmcoKSAqIDB4MjAwMDAwIHwgMCkgKiAxLjExMDIyMzAyNDYyNTE1NjVlLTE2OyAvLyAyXi01M1xuICB9O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuZnVuY3Rpb24gTWFzaCgpIHtcbiAgdmFyIG4gPSAweGVmYzgyNDlkO1xuXG4gIHZhciBtYXNoID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIGRhdGEgPSBTdHJpbmcoZGF0YSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuICs9IGRhdGEuY2hhckNvZGVBdChpKTtcbiAgICAgIHZhciBoID0gMC4wMjUxOTYwMzI4MjQxNjkzOCAqIG47XG4gICAgICBuID0gaCA+Pj4gMDtcbiAgICAgIGggLT0gbjtcbiAgICAgIGggKj0gbjtcbiAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgaCAtPSBuO1xuICAgICAgbiArPSBoICogMHgxMDAwMDAwMDA7IC8vIDJeMzJcbiAgICB9XG4gICAgcmV0dXJuIChuID4+PiAwKSAqIDIuMzI4MzA2NDM2NTM4Njk2M2UtMTA7IC8vIDJeLTMyXG4gIH07XG5cbiAgcmV0dXJuIG1hc2g7XG59XG5cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy5hbGVhID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuXG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwibW9kdWxlIiwiZGVmaW5lIiwiQWxlYSIsInNlZWQiLCJtZSIsIm1hc2giLCJNYXNoIiwibmV4dCIsInQiLCJzMCIsImMiLCJzMSIsInMyIiwiY29weSIsImYiLCJpbXBsIiwib3B0cyIsInhnIiwic3RhdGUiLCJwcm5nIiwiaW50MzIiLCJkb3VibGUiLCJxdWljayIsIm4iLCJkYXRhIiwiU3RyaW5nIiwiaSIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJoIiwiZXhwb3J0cyIsImFtZCIsImFsZWEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/seedrandom/lib/alea.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/seedrandom/lib/tychei.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/tychei.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the \"Tyche-i\" prng algorithm by\n// Samuel Neves and Filipe Araujo.\n// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf\n(function(global, module1, define1) {\n    function XorGen(seed) {\n        var me = this, strseed = \"\";\n        // Set up generator function.\n        me.next = function() {\n            var b = me.b, c = me.c, d = me.d, a = me.a;\n            b = b << 25 ^ b >>> 7 ^ c;\n            c = c - d | 0;\n            d = d << 24 ^ d >>> 8 ^ a;\n            a = a - b | 0;\n            me.b = b = b << 20 ^ b >>> 12 ^ c;\n            me.c = c = c - d | 0;\n            me.d = d << 16 ^ c >>> 16 ^ a;\n            return me.a = a - b | 0;\n        };\n        /* The following is non-inverted tyche, which has better internal\n   * bit diffusion, but which is about 25% slower than tyche-i in JS.\n  me.next = function() {\n    var a = me.a, b = me.b, c = me.c, d = me.d;\n    a = (me.a + me.b | 0) >>> 0;\n    d = me.d ^ a; d = d << 16 ^ d >>> 16;\n    c = me.c + d | 0;\n    b = me.b ^ c; b = b << 12 ^ d >>> 20;\n    me.a = a = a + b | 0;\n    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;\n    me.c = c = c + d | 0;\n    b = b ^ c;\n    return me.b = (b << 7 ^ b >>> 25);\n  }\n  */ me.a = 0;\n        me.b = 0;\n        me.c = 2654435769 | 0;\n        me.d = 1367130551;\n        if (seed === Math.floor(seed)) {\n            // Integer seed.\n            me.a = seed / 0x100000000 | 0;\n            me.b = seed | 0;\n        } else {\n            // String seed.\n            strseed += seed;\n        }\n        // Mix in string seed, then discard an initial batch of 64 values.\n        for(var k = 0; k < strseed.length + 20; k++){\n            me.b ^= strseed.charCodeAt(k) | 0;\n            me.next();\n        }\n    }\n    function copy(f, t) {\n        t.a = f.a;\n        t.b = f.b;\n        t.c = f.c;\n        t.d = f.d;\n        return t;\n    }\n    ;\n    function impl(seed, opts) {\n        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {\n            return (xg.next() >>> 0) / 0x100000000;\n        };\n        prng.double = function() {\n            do {\n                var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / (1 << 21);\n            }while (result === 0);\n            return result;\n        };\n        prng.int32 = xg.next;\n        prng.quick = prng;\n        if (state) {\n            if (typeof state == \"object\") copy(state, xg);\n            prng.state = function() {\n                return copy(xg, {});\n            };\n        }\n        return prng;\n    }\n    if (module1 && module1.exports) {\n        module1.exports = impl;\n    } else if (__webpack_require__.amdD && __webpack_require__.amdO) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return impl;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {\n        this.tychei = impl;\n    }\n})(this,  true && module, __webpack_require__.amdD // present with an AMD loader\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIvdHljaGVpLmpzIiwibWFwcGluZ3MiOiI7QUFBQSxrR0FBZ0U7QUFDaEUsa0NBQWtDO0FBQ2xDLHlEQUF5RDtBQUV4RCxVQUFTQSxNQUFNLEVBQUVDLE9BQU0sRUFBRUMsT0FBTTtJQUVoQyxTQUFTQyxPQUFPQyxJQUFJO1FBQ2xCLElBQUlDLEtBQUssSUFBSSxFQUFFQyxVQUFVO1FBRXpCLDZCQUE2QjtRQUM3QkQsR0FBR0UsSUFBSSxHQUFHO1lBQ1IsSUFBSUMsSUFBSUgsR0FBR0csQ0FBQyxFQUFFQyxJQUFJSixHQUFHSSxDQUFDLEVBQUVDLElBQUlMLEdBQUdLLENBQUMsRUFBRUMsSUFBSU4sR0FBR00sQ0FBQztZQUMxQ0gsSUFBSSxLQUFNLEtBQU9BLE1BQU0sSUFBS0M7WUFDNUJBLElBQUksSUFBS0MsSUFBSztZQUNkQSxJQUFJLEtBQU0sS0FBT0EsTUFBTSxJQUFLQztZQUM1QkEsSUFBSSxJQUFLSCxJQUFLO1lBQ2RILEdBQUdHLENBQUMsR0FBR0EsSUFBSSxLQUFNLEtBQU9BLE1BQU0sS0FBTUM7WUFDcENKLEdBQUdJLENBQUMsR0FBR0EsSUFBSSxJQUFLQyxJQUFLO1lBQ3JCTCxHQUFHSyxDQUFDLEdBQUcsS0FBTSxLQUFPRCxNQUFNLEtBQU1FO1lBQ2hDLE9BQU9OLEdBQUdNLENBQUMsR0FBRyxJQUFLSCxJQUFLO1FBQzFCO1FBRUE7Ozs7Ozs7Ozs7Ozs7O0VBY0EsR0FFQUgsR0FBR00sQ0FBQyxHQUFHO1FBQ1BOLEdBQUdHLENBQUMsR0FBRztRQUNQSCxHQUFHSSxDQUFDLEdBQUcsYUFBYTtRQUNwQkosR0FBR0ssQ0FBQyxHQUFHO1FBRVAsSUFBSU4sU0FBU1EsS0FBS0MsS0FBSyxDQUFDVCxPQUFPO1lBQzdCLGdCQUFnQjtZQUNoQkMsR0FBR00sQ0FBQyxHQUFHLE9BQVEsY0FBZTtZQUM5Qk4sR0FBR0csQ0FBQyxHQUFHSixPQUFPO1FBQ2hCLE9BQU87WUFDTCxlQUFlO1lBQ2ZFLFdBQVdGO1FBQ2I7UUFFQSxrRUFBa0U7UUFDbEUsSUFBSyxJQUFJVSxJQUFJLEdBQUdBLElBQUlSLFFBQVFTLE1BQU0sR0FBRyxJQUFJRCxJQUFLO1lBQzVDVCxHQUFHRyxDQUFDLElBQUlGLFFBQVFVLFVBQVUsQ0FBQ0YsS0FBSztZQUNoQ1QsR0FBR0UsSUFBSTtRQUNUO0lBQ0Y7SUFFQSxTQUFTVSxLQUFLQyxDQUFDLEVBQUVDLENBQUM7UUFDaEJBLEVBQUVSLENBQUMsR0FBR08sRUFBRVAsQ0FBQztRQUNUUSxFQUFFWCxDQUFDLEdBQUdVLEVBQUVWLENBQUM7UUFDVFcsRUFBRVYsQ0FBQyxHQUFHUyxFQUFFVCxDQUFDO1FBQ1RVLEVBQUVULENBQUMsR0FBR1EsRUFBRVIsQ0FBQztRQUNULE9BQU9TO0lBQ1Q7O0lBRUEsU0FBU0MsS0FBS2hCLElBQUksRUFBRWlCLElBQUk7UUFDdEIsSUFBSUMsS0FBSyxJQUFJbkIsT0FBT0MsT0FDaEJtQixRQUFRRixRQUFRQSxLQUFLRSxLQUFLLEVBQzFCQyxPQUFPO1lBQWEsT0FBTyxDQUFDRixHQUFHZixJQUFJLE9BQU8sS0FBSztRQUFhO1FBQ2hFaUIsS0FBS0MsTUFBTSxHQUFHO1lBQ1osR0FBRztnQkFDRCxJQUFJQyxNQUFNSixHQUFHZixJQUFJLE9BQU8sSUFDcEJvQixNQUFNLENBQUNMLEdBQUdmLElBQUksT0FBTyxLQUFLLGFBQzFCcUIsU0FBUyxDQUFDRixNQUFNQyxHQUFFLElBQU0sTUFBSyxFQUFDO1lBQ3BDLFFBQVNDLFdBQVcsR0FBRztZQUN2QixPQUFPQTtRQUNUO1FBQ0FKLEtBQUtLLEtBQUssR0FBR1AsR0FBR2YsSUFBSTtRQUNwQmlCLEtBQUtNLEtBQUssR0FBR047UUFDYixJQUFJRCxPQUFPO1lBQ1QsSUFBSSxPQUFPQSxTQUFVLFVBQVVOLEtBQUtNLE9BQU9EO1lBQzNDRSxLQUFLRCxLQUFLLEdBQUc7Z0JBQWEsT0FBT04sS0FBS0ssSUFBSSxDQUFDO1lBQUk7UUFDakQ7UUFDQSxPQUFPRTtJQUNUO0lBRUEsSUFBSXZCLFdBQVVBLFFBQU84QixPQUFPLEVBQUU7UUFDNUI5QixRQUFPOEIsT0FBTyxHQUFHWDtJQUNuQixPQUFPLElBQUlsQix3QkFBQUEsSUFBVUEsd0JBQVUsRUFBRTtRQUMvQkEsbUNBQU87WUFBYSxPQUFPa0I7UUFBTSxDQUFDO0FBQUEsa0dBQUM7SUFDckMsT0FBTztRQUNMLElBQUksQ0FBQ2EsTUFBTSxHQUFHYjtJQUNoQjtBQUVBLEdBQ0UsSUFBSSxFQUNKLEtBQW1CLElBQVluQixRQUMvQix3QkFBdUNDLENBQUcsNkJBQTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8veW9nYXBvc2VwZXJmZWN0Ly4vbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3R5Y2hlaS5qcz9mNjIzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcIlR5Y2hlLWlcIiBwcm5nIGFsZ29yaXRobSBieVxuLy8gU2FtdWVsIE5ldmVzIGFuZCBGaWxpcGUgQXJhdWpvLlxuLy8gU2VlIGh0dHBzOi8vZWRlbi5kZWkudWMucHQvfnNuZXZlcy9wdWJzLzIwMTEtc25mYTIucGRmXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIHN0cnNlZWQgPSAnJztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGIgPSBtZS5iLCBjID0gbWUuYywgZCA9IG1lLmQsIGEgPSBtZS5hO1xuICAgIGIgPSAoYiA8PCAyNSkgXiAoYiA+Pj4gNykgXiBjO1xuICAgIGMgPSAoYyAtIGQpIHwgMDtcbiAgICBkID0gKGQgPDwgMjQpIF4gKGQgPj4+IDgpIF4gYTtcbiAgICBhID0gKGEgLSBiKSB8IDA7XG4gICAgbWUuYiA9IGIgPSAoYiA8PCAyMCkgXiAoYiA+Pj4gMTIpIF4gYztcbiAgICBtZS5jID0gYyA9IChjIC0gZCkgfCAwO1xuICAgIG1lLmQgPSAoZCA8PCAxNikgXiAoYyA+Pj4gMTYpIF4gYTtcbiAgICByZXR1cm4gbWUuYSA9IChhIC0gYikgfCAwO1xuICB9O1xuXG4gIC8qIFRoZSBmb2xsb3dpbmcgaXMgbm9uLWludmVydGVkIHR5Y2hlLCB3aGljaCBoYXMgYmV0dGVyIGludGVybmFsXG4gICAqIGJpdCBkaWZmdXNpb24sIGJ1dCB3aGljaCBpcyBhYm91dCAyNSUgc2xvd2VyIHRoYW4gdHljaGUtaSBpbiBKUy5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhID0gbWUuYSwgYiA9IG1lLmIsIGMgPSBtZS5jLCBkID0gbWUuZDtcbiAgICBhID0gKG1lLmEgKyBtZS5iIHwgMCkgPj4+IDA7XG4gICAgZCA9IG1lLmQgXiBhOyBkID0gZCA8PCAxNiBeIGQgPj4+IDE2O1xuICAgIGMgPSBtZS5jICsgZCB8IDA7XG4gICAgYiA9IG1lLmIgXiBjOyBiID0gYiA8PCAxMiBeIGQgPj4+IDIwO1xuICAgIG1lLmEgPSBhID0gYSArIGIgfCAwO1xuICAgIGQgPSBkIF4gYTsgbWUuZCA9IGQgPSBkIDw8IDggXiBkID4+PiAyNDtcbiAgICBtZS5jID0gYyA9IGMgKyBkIHwgMDtcbiAgICBiID0gYiBeIGM7XG4gICAgcmV0dXJuIG1lLmIgPSAoYiA8PCA3IF4gYiA+Pj4gMjUpO1xuICB9XG4gICovXG5cbiAgbWUuYSA9IDA7XG4gIG1lLmIgPSAwO1xuICBtZS5jID0gMjY1NDQzNTc2OSB8IDA7XG4gIG1lLmQgPSAxMzY3MTMwNTUxO1xuXG4gIGlmIChzZWVkID09PSBNYXRoLmZsb29yKHNlZWQpKSB7XG4gICAgLy8gSW50ZWdlciBzZWVkLlxuICAgIG1lLmEgPSAoc2VlZCAvIDB4MTAwMDAwMDAwKSB8IDA7XG4gICAgbWUuYiA9IHNlZWQgfCAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0cmluZyBzZWVkLlxuICAgIHN0cnNlZWQgKz0gc2VlZDtcbiAgfVxuXG4gIC8vIE1peCBpbiBzdHJpbmcgc2VlZCwgdGhlbiBkaXNjYXJkIGFuIGluaXRpYWwgYmF0Y2ggb2YgNjQgdmFsdWVzLlxuICBmb3IgKHZhciBrID0gMDsgayA8IHN0cnNlZWQubGVuZ3RoICsgMjA7IGsrKykge1xuICAgIG1lLmIgXj0gc3Ryc2VlZC5jaGFyQ29kZUF0KGspIHwgMDtcbiAgICBtZS5uZXh0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuYSA9IGYuYTtcbiAgdC5iID0gZi5iO1xuICB0LmMgPSBmLmM7XG4gIHQuZCA9IGYuZDtcbiAgcmV0dXJuIHQ7XG59O1xuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnR5Y2hlaSA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIl0sIm5hbWVzIjpbImdsb2JhbCIsIm1vZHVsZSIsImRlZmluZSIsIlhvckdlbiIsInNlZWQiLCJtZSIsInN0cnNlZWQiLCJuZXh0IiwiYiIsImMiLCJkIiwiYSIsIk1hdGgiLCJmbG9vciIsImsiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiY29weSIsImYiLCJ0IiwiaW1wbCIsIm9wdHMiLCJ4ZyIsInN0YXRlIiwicHJuZyIsImRvdWJsZSIsInRvcCIsImJvdCIsInJlc3VsdCIsImludDMyIiwicXVpY2siLCJleHBvcnRzIiwiYW1kIiwidHljaGVpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/seedrandom/lib/tychei.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/seedrandom/lib/xor128.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/xor128.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the \"xor128\" prng algorithm by\n// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper\n(function(global, module1, define1) {\n    function XorGen(seed) {\n        var me = this, strseed = \"\";\n        me.x = 0;\n        me.y = 0;\n        me.z = 0;\n        me.w = 0;\n        // Set up generator function.\n        me.next = function() {\n            var t = me.x ^ me.x << 11;\n            me.x = me.y;\n            me.y = me.z;\n            me.z = me.w;\n            return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;\n        };\n        if (seed === (seed | 0)) {\n            // Integer seed.\n            me.x = seed;\n        } else {\n            // String seed.\n            strseed += seed;\n        }\n        // Mix in string seed, then discard an initial batch of 64 values.\n        for(var k = 0; k < strseed.length + 64; k++){\n            me.x ^= strseed.charCodeAt(k) | 0;\n            me.next();\n        }\n    }\n    function copy(f, t) {\n        t.x = f.x;\n        t.y = f.y;\n        t.z = f.z;\n        t.w = f.w;\n        return t;\n    }\n    function impl(seed, opts) {\n        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {\n            return (xg.next() >>> 0) / 0x100000000;\n        };\n        prng.double = function() {\n            do {\n                var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / (1 << 21);\n            }while (result === 0);\n            return result;\n        };\n        prng.int32 = xg.next;\n        prng.quick = prng;\n        if (state) {\n            if (typeof state == \"object\") copy(state, xg);\n            prng.state = function() {\n                return copy(xg, {});\n            };\n        }\n        return prng;\n    }\n    if (module1 && module1.exports) {\n        module1.exports = impl;\n    } else if (__webpack_require__.amdD && __webpack_require__.amdO) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return impl;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {\n        this.xor128 = impl;\n    }\n})(this,  true && module, __webpack_require__.amdD // present with an AMD loader\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yMTI4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxpR0FBK0Q7QUFDL0QsZ0VBQWdFO0FBRS9ELFVBQVNBLE1BQU0sRUFBRUMsT0FBTSxFQUFFQyxPQUFNO0lBRWhDLFNBQVNDLE9BQU9DLElBQUk7UUFDbEIsSUFBSUMsS0FBSyxJQUFJLEVBQUVDLFVBQVU7UUFFekJELEdBQUdFLENBQUMsR0FBRztRQUNQRixHQUFHRyxDQUFDLEdBQUc7UUFDUEgsR0FBR0ksQ0FBQyxHQUFHO1FBQ1BKLEdBQUdLLENBQUMsR0FBRztRQUVQLDZCQUE2QjtRQUM3QkwsR0FBR00sSUFBSSxHQUFHO1lBQ1IsSUFBSUMsSUFBSVAsR0FBR0UsQ0FBQyxHQUFJRixHQUFHRSxDQUFDLElBQUk7WUFDeEJGLEdBQUdFLENBQUMsR0FBR0YsR0FBR0csQ0FBQztZQUNYSCxHQUFHRyxDQUFDLEdBQUdILEdBQUdJLENBQUM7WUFDWEosR0FBR0ksQ0FBQyxHQUFHSixHQUFHSyxDQUFDO1lBQ1gsT0FBT0wsR0FBR0ssQ0FBQyxJQUFJLEdBQUlBLENBQUMsS0FBSyxLQUFNRSxJQUFLQSxNQUFNO1FBQzVDO1FBRUEsSUFBSVIsU0FBVUEsQ0FBQUEsT0FBTyxJQUFJO1lBQ3ZCLGdCQUFnQjtZQUNoQkMsR0FBR0UsQ0FBQyxHQUFHSDtRQUNULE9BQU87WUFDTCxlQUFlO1lBQ2ZFLFdBQVdGO1FBQ2I7UUFFQSxrRUFBa0U7UUFDbEUsSUFBSyxJQUFJUyxJQUFJLEdBQUdBLElBQUlQLFFBQVFRLE1BQU0sR0FBRyxJQUFJRCxJQUFLO1lBQzVDUixHQUFHRSxDQUFDLElBQUlELFFBQVFTLFVBQVUsQ0FBQ0YsS0FBSztZQUNoQ1IsR0FBR00sSUFBSTtRQUNUO0lBQ0Y7SUFFQSxTQUFTSyxLQUFLQyxDQUFDLEVBQUVMLENBQUM7UUFDaEJBLEVBQUVMLENBQUMsR0FBR1UsRUFBRVYsQ0FBQztRQUNUSyxFQUFFSixDQUFDLEdBQUdTLEVBQUVULENBQUM7UUFDVEksRUFBRUgsQ0FBQyxHQUFHUSxFQUFFUixDQUFDO1FBQ1RHLEVBQUVGLENBQUMsR0FBR08sRUFBRVAsQ0FBQztRQUNULE9BQU9FO0lBQ1Q7SUFFQSxTQUFTTSxLQUFLZCxJQUFJLEVBQUVlLElBQUk7UUFDdEIsSUFBSUMsS0FBSyxJQUFJakIsT0FBT0MsT0FDaEJpQixRQUFRRixRQUFRQSxLQUFLRSxLQUFLLEVBQzFCQyxPQUFPO1lBQWEsT0FBTyxDQUFDRixHQUFHVCxJQUFJLE9BQU8sS0FBSztRQUFhO1FBQ2hFVyxLQUFLQyxNQUFNLEdBQUc7WUFDWixHQUFHO2dCQUNELElBQUlDLE1BQU1KLEdBQUdULElBQUksT0FBTyxJQUNwQmMsTUFBTSxDQUFDTCxHQUFHVCxJQUFJLE9BQU8sS0FBSyxhQUMxQmUsU0FBUyxDQUFDRixNQUFNQyxHQUFFLElBQU0sTUFBSyxFQUFDO1lBQ3BDLFFBQVNDLFdBQVcsR0FBRztZQUN2QixPQUFPQTtRQUNUO1FBQ0FKLEtBQUtLLEtBQUssR0FBR1AsR0FBR1QsSUFBSTtRQUNwQlcsS0FBS00sS0FBSyxHQUFHTjtRQUNiLElBQUlELE9BQU87WUFDVCxJQUFJLE9BQU9BLFNBQVUsVUFBVUwsS0FBS0ssT0FBT0Q7WUFDM0NFLEtBQUtELEtBQUssR0FBRztnQkFBYSxPQUFPTCxLQUFLSSxJQUFJLENBQUM7WUFBSTtRQUNqRDtRQUNBLE9BQU9FO0lBQ1Q7SUFFQSxJQUFJckIsV0FBVUEsUUFBTzRCLE9BQU8sRUFBRTtRQUM1QjVCLFFBQU80QixPQUFPLEdBQUdYO0lBQ25CLE9BQU8sSUFBSWhCLHdCQUFBQSxJQUFVQSx3QkFBVSxFQUFFO1FBQy9CQSxtQ0FBTztZQUFhLE9BQU9nQjtRQUFNLENBQUM7QUFBQSxrR0FBQztJQUNyQyxPQUFPO1FBQ0wsSUFBSSxDQUFDYSxNQUFNLEdBQUdiO0lBQ2hCO0FBRUEsR0FDRSxJQUFJLEVBQ0osS0FBbUIsSUFBWWpCLFFBQy9CLHdCQUF1Q0MsQ0FBRyw2QkFBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95b2dhcG9zZXBlcmZlY3QvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yMTI4LmpzPzBhZWQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwieG9yMTI4XCIgcHJuZyBhbGdvcml0aG0gYnlcbi8vIEdlb3JnZSBNYXJzYWdsaWEuICBTZWUgaHR0cDovL3d3dy5qc3RhdHNvZnQub3JnL3YwOC9pMTQvcGFwZXJcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgc3Ryc2VlZCA9ICcnO1xuXG4gIG1lLnggPSAwO1xuICBtZS55ID0gMDtcbiAgbWUueiA9IDA7XG4gIG1lLncgPSAwO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IG1lLnggXiAobWUueCA8PCAxMSk7XG4gICAgbWUueCA9IG1lLnk7XG4gICAgbWUueSA9IG1lLno7XG4gICAgbWUueiA9IG1lLnc7XG4gICAgcmV0dXJuIG1lLncgXj0gKG1lLncgPj4+IDE5KSBeIHQgXiAodCA+Pj4gOCk7XG4gIH07XG5cbiAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAvLyBJbnRlZ2VyIHNlZWQuXG4gICAgbWUueCA9IHNlZWQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RyaW5nIHNlZWQuXG4gICAgc3Ryc2VlZCArPSBzZWVkO1xuICB9XG5cbiAgLy8gTWl4IGluIHN0cmluZyBzZWVkLCB0aGVuIGRpc2NhcmQgYW4gaW5pdGlhbCBiYXRjaCBvZiA2NCB2YWx1ZXMuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgc3Ryc2VlZC5sZW5ndGggKyA2NDsgaysrKSB7XG4gICAgbWUueCBePSBzdHJzZWVkLmNoYXJDb2RlQXQoaykgfCAwO1xuICAgIG1lLm5leHQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC54ID0gZi54O1xuICB0LnkgPSBmLnk7XG4gIHQueiA9IGYuejtcbiAgdC53ID0gZi53O1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3IxMjggPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiJdLCJuYW1lcyI6WyJnbG9iYWwiLCJtb2R1bGUiLCJkZWZpbmUiLCJYb3JHZW4iLCJzZWVkIiwibWUiLCJzdHJzZWVkIiwieCIsInkiLCJ6IiwidyIsIm5leHQiLCJ0IiwiayIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJjb3B5IiwiZiIsImltcGwiLCJvcHRzIiwieGciLCJzdGF0ZSIsInBybmciLCJkb3VibGUiLCJ0b3AiLCJib3QiLCJyZXN1bHQiLCJpbnQzMiIsInF1aWNrIiwiZXhwb3J0cyIsImFtZCIsInhvcjEyOCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/seedrandom/lib/xor128.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/seedrandom/lib/xor4096.js":
/*!************************************************!*\
  !*** ./node_modules/seedrandom/lib/xor4096.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.\n//\n// This fast non-cryptographic random number generator is designed for\n// use in Monte-Carlo algorithms. It combines a long-period xorshift\n// generator with a Weyl generator, and it passes all common batteries\n// of stasticial tests for randomness while consuming only a few nanoseconds\n// for each prng generated.  For background on the generator, see Brent's\n// paper: \"Some long-period random number generators using shifts and xors.\"\n// http://arxiv.org/pdf/1004.3115v1.pdf\n//\n// Usage:\n//\n// var xor4096 = require('xor4096');\n// random = xor4096(1);                        // Seed with int32 or string.\n// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.\n// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.\n//\n// For nonzero numeric keys, this impelementation provides a sequence\n// identical to that by Brent's xorgens 3 implementaion in C.  This\n// implementation also provides for initalizing the generator with\n// string seeds, or for saving and restoring the state of the generator.\n//\n// On Chrome, this prng benchmarks about 2.1 times slower than\n// Javascript's built-in Math.random().\n(function(global, module1, define1) {\n    function XorGen(seed) {\n        var me = this;\n        // Set up generator function.\n        me.next = function() {\n            var w = me.w, X = me.X, i = me.i, t, v;\n            // Update Weyl generator.\n            me.w = w = w + 0x61c88647 | 0;\n            // Update xor generator.\n            v = X[i + 34 & 127];\n            t = X[i = i + 1 & 127];\n            v ^= v << 13;\n            t ^= t << 17;\n            v ^= v >>> 15;\n            t ^= t >>> 12;\n            // Update Xor generator array state.\n            v = X[i] = v ^ t;\n            me.i = i;\n            // Result is the combination.\n            return v + (w ^ w >>> 16) | 0;\n        };\n        function init(me, seed) {\n            var t, v, i, j, w, X = [], limit = 128;\n            if (seed === (seed | 0)) {\n                // Numeric seeds initialize v, which is used to generates X.\n                v = seed;\n                seed = null;\n            } else {\n                // String seeds are mixed into v and X one character at a time.\n                seed = seed + \"\\x00\";\n                v = 0;\n                limit = Math.max(limit, seed.length);\n            }\n            // Initialize circular array and weyl value.\n            for(i = 0, j = -32; j < limit; ++j){\n                // Put the unicode characters into the array, and shuffle them.\n                if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);\n                // After 32 shuffles, take v as the starting w value.\n                if (j === 0) w = v;\n                v ^= v << 10;\n                v ^= v >>> 15;\n                v ^= v << 4;\n                v ^= v >>> 13;\n                if (j >= 0) {\n                    w = w + 0x61c88647 | 0; // Weyl.\n                    t = X[j & 127] ^= v + w; // Combine xor and weyl to init array.\n                    i = 0 == t ? i + 1 : 0; // Count zeroes.\n                }\n            }\n            // We have detected all zeroes; make the key nonzero.\n            if (i >= 128) {\n                X[(seed && seed.length || 0) & 127] = -1;\n            }\n            // Run the generator 512 times to further mix the state before using it.\n            // Factoring this as a function slows the main generator, so it is just\n            // unrolled here.  The weyl generator is not advanced while warming up.\n            i = 127;\n            for(j = 4 * 128; j > 0; --j){\n                v = X[i + 34 & 127];\n                t = X[i = i + 1 & 127];\n                v ^= v << 13;\n                t ^= t << 17;\n                v ^= v >>> 15;\n                t ^= t >>> 12;\n                X[i] = v ^ t;\n            }\n            // Storing state as object members is faster than using closure variables.\n            me.w = w;\n            me.X = X;\n            me.i = i;\n        }\n        init(me, seed);\n    }\n    function copy(f, t) {\n        t.i = f.i;\n        t.w = f.w;\n        t.X = f.X.slice();\n        return t;\n    }\n    ;\n    function impl(seed, opts) {\n        if (seed == null) seed = +new Date;\n        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {\n            return (xg.next() >>> 0) / 0x100000000;\n        };\n        prng.double = function() {\n            do {\n                var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / (1 << 21);\n            }while (result === 0);\n            return result;\n        };\n        prng.int32 = xg.next;\n        prng.quick = prng;\n        if (state) {\n            if (state.X) copy(state, xg);\n            prng.state = function() {\n                return copy(xg, {});\n            };\n        }\n        return prng;\n    }\n    if (module1 && module1.exports) {\n        module1.exports = impl;\n    } else if (__webpack_require__.amdD && __webpack_require__.amdO) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return impl;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {\n        this.xor4096 = impl;\n    }\n})(this,  true && module, __webpack_require__.amdD // present with an AMD loader\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yNDA5Ni5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsNkdBQTJFO0FBQzNFLEVBQUU7QUFDRixzRUFBc0U7QUFDdEUsb0VBQW9FO0FBQ3BFLHNFQUFzRTtBQUN0RSw0RUFBNEU7QUFDNUUseUVBQXlFO0FBQ3pFLDRFQUE0RTtBQUM1RSx1Q0FBdUM7QUFDdkMsRUFBRTtBQUNGLFNBQVM7QUFDVCxFQUFFO0FBQ0Ysb0NBQW9DO0FBQ3BDLDRFQUE0RTtBQUM1RSx3RUFBd0U7QUFDeEUsd0VBQXdFO0FBQ3hFLEVBQUU7QUFDRixxRUFBcUU7QUFDckUsbUVBQW1FO0FBQ25FLGtFQUFrRTtBQUNsRSx3RUFBd0U7QUFDeEUsRUFBRTtBQUNGLDhEQUE4RDtBQUM5RCx1Q0FBdUM7QUFFdEMsVUFBU0EsTUFBTSxFQUFFQyxPQUFNLEVBQUVDLE9BQU07SUFFaEMsU0FBU0MsT0FBT0MsSUFBSTtRQUNsQixJQUFJQyxLQUFLLElBQUk7UUFFYiw2QkFBNkI7UUFDN0JBLEdBQUdDLElBQUksR0FBRztZQUNSLElBQUlDLElBQUlGLEdBQUdFLENBQUMsRUFDUkMsSUFBSUgsR0FBR0csQ0FBQyxFQUFFQyxJQUFJSixHQUFHSSxDQUFDLEVBQUVDLEdBQUdDO1lBQzNCLHlCQUF5QjtZQUN6Qk4sR0FBR0UsQ0FBQyxHQUFHQSxJQUFJLElBQUssYUFBYztZQUM5Qix3QkFBd0I7WUFDeEJJLElBQUlILENBQUMsQ0FBQyxJQUFLLEtBQU0sSUFBSTtZQUNyQkUsSUFBSUYsQ0FBQyxDQUFDQyxJQUFLLElBQUssSUFBSyxJQUFLO1lBQzFCRSxLQUFLQSxLQUFLO1lBQ1ZELEtBQUtBLEtBQUs7WUFDVkMsS0FBS0EsTUFBTTtZQUNYRCxLQUFLQSxNQUFNO1lBQ1gsb0NBQW9DO1lBQ3BDQyxJQUFJSCxDQUFDLENBQUNDLEVBQUUsR0FBR0UsSUFBSUQ7WUFDZkwsR0FBR0ksQ0FBQyxHQUFHQTtZQUNQLDZCQUE2QjtZQUM3QixPQUFPLElBQU1G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QUFHO1lBQ3ZCLE9BQU9BO1FBQ1Q7UUFDQUosS0FBS0ssS0FBSyxHQUFHUCxHQUFHbkIsSUFBSTtRQUNwQnFCLEtBQUtNLEtBQUssR0FBR047UUFDYixJQUFJRCxPQUFPO1lBQ1QsSUFBSUEsTUFBTWxCLENBQUMsRUFBRVcsS0FBS08sT0FBT0Q7WUFDekJFLEtBQUtELEtBQUssR0FBRztnQkFBYSxPQUFPUCxLQUFLTSxJQUFJLENBQUM7WUFBSTtRQUNqRDtRQUNBLE9BQU9FO0lBQ1Q7SUFFQSxJQUFJMUIsV0FBVUEsUUFBT2lDLE9BQU8sRUFBRTtRQUM1QmpDLFFBQU9pQyxPQUFPLEdBQUdaO0lBQ25CLE9BQU8sSUFBSXBCLHdCQUFBQSxJQUFVQSx3QkFBVSxFQUFFO1FBQy9CQSxtQ0FBTztZQUFhLE9BQU9vQjtRQUFNLENBQUM7QUFBQSxrR0FBQztJQUNyQyxPQUFPO1FBQ0wsSUFBSSxDQUFDYyxPQUFPLEdBQUdkO0lBQ2pCO0FBRUEsR0FDRSxJQUFJLEVBQ0osS0FBbUIsSUFBWXJCLFFBQy9CLHdCQUF1Q0MsQ0FBRyw2QkFBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95b2dhcG9zZXBlcmZlY3QvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yNDA5Ni5qcz81YTZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIFJpY2hhcmQgQnJlbnQncyBYb3JnZW5zIHhvcjQwOTYgYWxnb3JpdGhtLlxuLy9cbi8vIFRoaXMgZmFzdCBub24tY3J5cHRvZ3JhcGhpYyByYW5kb20gbnVtYmVyIGdlbmVyYXRvciBpcyBkZXNpZ25lZCBmb3Jcbi8vIHVzZSBpbiBNb250ZS1DYXJsbyBhbGdvcml0aG1zLiBJdCBjb21iaW5lcyBhIGxvbmctcGVyaW9kIHhvcnNoaWZ0XG4vLyBnZW5lcmF0b3Igd2l0aCBhIFdleWwgZ2VuZXJhdG9yLCBhbmQgaXQgcGFzc2VzIGFsbCBjb21tb24gYmF0dGVyaWVzXG4vLyBvZiBzdGFzdGljaWFsIHRlc3RzIGZvciByYW5kb21uZXNzIHdoaWxlIGNvbnN1bWluZyBvbmx5IGEgZmV3IG5hbm9zZWNvbmRzXG4vLyBmb3IgZWFjaCBwcm5nIGdlbmVyYXRlZC4gIEZvciBiYWNrZ3JvdW5kIG9uIHRoZSBnZW5lcmF0b3IsIHNlZSBCcmVudCdzXG4vLyBwYXBlcjogXCJTb21lIGxvbmctcGVyaW9kIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9ycyB1c2luZyBzaGlmdHMgYW5kIHhvcnMuXCJcbi8vIGh0dHA6Ly9hcnhpdi5vcmcvcGRmLzEwMDQuMzExNXYxLnBkZlxuLy9cbi8vIFVzYWdlOlxuLy9cbi8vIHZhciB4b3I0MDk2ID0gcmVxdWlyZSgneG9yNDA5NicpO1xuLy8gcmFuZG9tID0geG9yNDA5NigxKTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWVkIHdpdGggaW50MzIgb3Igc3RyaW5nLlxuLy8gYXNzZXJ0LmVxdWFsKHJhbmRvbSgpLCAwLjE1MjA0MzY0NTA1Mzg1NDcpOyAvLyAoMCwgMSkgcmFuZ2UsIDUzIGJpdHMuXG4vLyBhc3NlcnQuZXF1YWwocmFuZG9tLmludDMyKCksIDE4MDY1MzQ4OTcpOyAgIC8vIHNpZ25lZCBpbnQzMiwgMzIgYml0cy5cbi8vXG4vLyBGb3Igbm9uemVybyBudW1lcmljIGtleXMsIHRoaXMgaW1wZWxlbWVudGF0aW9uIHByb3ZpZGVzIGEgc2VxdWVuY2Vcbi8vIGlkZW50aWNhbCB0byB0aGF0IGJ5IEJyZW50J3MgeG9yZ2VucyAzIGltcGxlbWVudGFpb24gaW4gQy4gIFRoaXNcbi8vIGltcGxlbWVudGF0aW9uIGFsc28gcHJvdmlkZXMgZm9yIGluaXRhbGl6aW5nIHRoZSBnZW5lcmF0b3Igd2l0aFxuLy8gc3RyaW5nIHNlZWRzLCBvciBmb3Igc2F2aW5nIGFuZCByZXN0b3JpbmcgdGhlIHN0YXRlIG9mIHRoZSBnZW5lcmF0b3IuXG4vL1xuLy8gT24gQ2hyb21lLCB0aGlzIHBybmcgYmVuY2htYXJrcyBhYm91dCAyLjEgdGltZXMgc2xvd2VyIHRoYW5cbi8vIEphdmFzY3JpcHQncyBidWlsdC1pbiBNYXRoLnJhbmRvbSgpLlxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdyA9IG1lLncsXG4gICAgICAgIFggPSBtZS5YLCBpID0gbWUuaSwgdCwgdjtcbiAgICAvLyBVcGRhdGUgV2V5bCBnZW5lcmF0b3IuXG4gICAgbWUudyA9IHcgPSAodyArIDB4NjFjODg2NDcpIHwgMDtcbiAgICAvLyBVcGRhdGUgeG9yIGdlbmVyYXRvci5cbiAgICB2ID0gWFsoaSArIDM0KSAmIDEyN107XG4gICAgdCA9IFhbaSA9ICgoaSArIDEpICYgMTI3KV07XG4gICAgdiBePSB2IDw8IDEzO1xuICAgIHQgXj0gdCA8PCAxNztcbiAgICB2IF49IHYgPj4+IDE1O1xuICAgIHQgXj0gdCA+Pj4gMTI7XG4gICAgLy8gVXBkYXRlIFhvciBnZW5lcmF0b3IgYXJyYXkgc3RhdGUuXG4gICAgdiA9IFhbaV0gPSB2IF4gdDtcbiAgICBtZS5pID0gaTtcbiAgICAvLyBSZXN1bHQgaXMgdGhlIGNvbWJpbmF0aW9uLlxuICAgIHJldHVybiAodiArICh3IF4gKHcgPj4+IDE2KSkpIHwgMDtcbiAgfTtcblxuICBmdW5jdGlvbiBpbml0KG1lLCBzZWVkKSB7XG4gICAgdmFyIHQsIHYsIGksIGosIHcsIFggPSBbXSwgbGltaXQgPSAxMjg7XG4gICAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAgIC8vIE51bWVyaWMgc2VlZHMgaW5pdGlhbGl6ZSB2LCB3aGljaCBpcyB1c2VkIHRvIGdlbmVyYXRlcyBYLlxuICAgICAgdiA9IHNlZWQ7XG4gICAgICBzZWVkID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RyaW5nIHNlZWRzIGFyZSBtaXhlZCBpbnRvIHYgYW5kIFggb25lIGNoYXJhY3RlciBhdCBhIHRpbWUuXG4gICAgICBzZWVkID0gc2VlZCArICdcXDAnO1xuICAgICAgdiA9IDA7XG4gICAgICBsaW1pdCA9IE1hdGgubWF4KGxpbWl0LCBzZWVkLmxlbmd0aCk7XG4gICAgfVxuICAgIC8vIEluaXRpYWxpemUgY2lyY3VsYXIgYXJyYXkgYW5kIHdleWwgdmFsdWUuXG4gICAgZm9yIChpID0gMCwgaiA9IC0zMjsgaiA8IGxpbWl0OyArK2opIHtcbiAgICAgIC8vIFB1dCB0aGUgdW5pY29kZSBjaGFyYWN0ZXJzIGludG8gdGhlIGFycmF5LCBhbmQgc2h1ZmZsZSB0aGVtLlxuICAgICAgaWYgKHNlZWQpIHYgXj0gc2VlZC5jaGFyQ29kZUF0KChqICsgMzIpICUgc2VlZC5sZW5ndGgpO1xuICAgICAgLy8gQWZ0ZXIgMzIgc2h1ZmZsZXMsIHRha2UgdiBhcyB0aGUgc3RhcnRpbmcgdyB2YWx1ZS5cbiAgICAgIGlmIChqID09PSAwKSB3ID0gdjtcbiAgICAgIHYgXj0gdiA8PCAxMDtcbiAgICAgIHYgXj0gdiA+Pj4gMTU7XG4gICAgICB2IF49IHYgPDwgNDtcbiAgICAgIHYgXj0gdiA+Pj4gMTM7XG4gICAgICBpZiAoaiA+PSAwKSB7XG4gICAgICAgIHcgPSAodyArIDB4NjFjODg2NDcpIHwgMDsgICAgIC8vIFdleWwuXG4gICAgICAgIHQgPSAoWFtqICYgMTI3XSBePSAodiArIHcpKTsgIC8vIENvbWJpbmUgeG9yIGFuZCB3ZXlsIHRvIGluaXQgYXJyYXkuXG4gICAgICAgIGkgPSAoMCA9PSB0KSA/IGkgKyAxIDogMDsgICAgIC8vIENvdW50IHplcm9lcy5cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgaGF2ZSBkZXRlY3RlZCBhbGwgemVyb2VzOyBtYWtlIHRoZSBrZXkgbm9uemVyby5cbiAgICBpZiAoaSA+PSAxMjgpIHtcbiAgICAgIFhbKHNlZWQgJiYgc2VlZC5sZW5ndGggfHwgMCkgJiAxMjddID0gLTE7XG4gICAgfVxuICAgIC8vIFJ1biB0aGUgZ2VuZXJhdG9yIDUxMiB0aW1lcyB0byBmdXJ0aGVyIG1peCB0aGUgc3RhdGUgYmVmb3JlIHVzaW5nIGl0LlxuICAgIC8vIEZhY3RvcmluZyB0aGlzIGFzIGEgZnVuY3Rpb24gc2xvd3MgdGhlIG1haW4gZ2VuZXJhdG9yLCBzbyBpdCBpcyBqdXN0XG4gICAgLy8gdW5yb2xsZWQgaGVyZS4gIFRoZSB3ZXlsIGdlbmVyYXRvciBpcyBub3QgYWR2YW5jZWQgd2hpbGUgd2FybWluZyB1cC5cbiAgICBpID0gMTI3O1xuICAgIGZvciAoaiA9IDQgKiAxMjg7IGogPiAwOyAtLWopIHtcbiAgICAgIHYgPSBYWyhpICsgMzQpICYgMTI3XTtcbiAgICAgIHQgPSBYW2kgPSAoKGkgKyAxKSAmIDEyNyldO1xuICAgICAgdiBePSB2IDw8IDEzO1xuICAgICAgdCBePSB0IDw8IDE3O1xuICAgICAgdiBePSB2ID4+PiAxNTtcbiAgICAgIHQgXj0gdCA+Pj4gMTI7XG4gICAgICBYW2ldID0gdiBeIHQ7XG4gICAgfVxuICAgIC8vIFN0b3Jpbmcgc3RhdGUgYXMgb2JqZWN0IG1lbWJlcnMgaXMgZmFzdGVyIHRoYW4gdXNpbmcgY2xvc3VyZSB2YXJpYWJsZXMuXG4gICAgbWUudyA9IHc7XG4gICAgbWUuWCA9IFg7XG4gICAgbWUuaSA9IGk7XG4gIH1cblxuICBpbml0KG1lLCBzZWVkKTtcbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuaSA9IGYuaTtcbiAgdC53ID0gZi53O1xuICB0LlggPSBmLlguc2xpY2UoKTtcbiAgcmV0dXJuIHQ7XG59O1xuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgaWYgKHNlZWQgPT0gbnVsbCkgc2VlZCA9ICsobmV3IERhdGUpO1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5YKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMueG9yNDA5NiA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aW5kb3cgb2JqZWN0IG9yIGdsb2JhbFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwibW9kdWxlIiwiZGVmaW5lIiwiWG9yR2VuIiwic2VlZCIsIm1lIiwibmV4dCIsInciLCJYIiwiaSIsInQiLCJ2IiwiaW5pdCIsImoiLCJsaW1pdCIsIk1hdGgiLCJtYXgiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiY29weSIsImYiLCJzbGljZSIsImltcGwiLCJvcHRzIiwiRGF0ZSIsInhnIiwic3RhdGUiLCJwcm5nIiwiZG91YmxlIiwidG9wIiwiYm90IiwicmVzdWx0IiwiaW50MzIiLCJxdWljayIsImV4cG9ydHMiLCJhbWQiLCJ4b3I0MDk2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/seedrandom/lib/xor4096.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/seedrandom/lib/xorshift7.js":
/*!**************************************************!*\
  !*** ./node_modules/seedrandom/lib/xorshift7.js ***!
  \**************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the \"xorshift7\" algorithm by\n// François Panneton and Pierre L'ecuyer:\n// \"On the Xorgshift Random Number Generators\"\n// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf\n(function(global, module1, define1) {\n    function XorGen(seed) {\n        var me = this;\n        // Set up generator function.\n        me.next = function() {\n            // Update xor generator.\n            var X = me.x, i = me.i, t, v, w;\n            t = X[i];\n            t ^= t >>> 7;\n            v = t ^ t << 24;\n            t = X[i + 1 & 7];\n            v ^= t ^ t >>> 10;\n            t = X[i + 3 & 7];\n            v ^= t ^ t >>> 3;\n            t = X[i + 4 & 7];\n            v ^= t ^ t << 7;\n            t = X[i + 7 & 7];\n            t = t ^ t << 13;\n            v ^= t ^ t << 9;\n            X[i] = v;\n            me.i = i + 1 & 7;\n            return v;\n        };\n        function init(me, seed) {\n            var j, w, X = [];\n            if (seed === (seed | 0)) {\n                // Seed state array using a 32-bit integer.\n                w = X[0] = seed;\n            } else {\n                // Seed state using a string.\n                seed = \"\" + seed;\n                for(j = 0; j < seed.length; ++j){\n                    X[j & 7] = X[j & 7] << 15 ^ seed.charCodeAt(j) + X[j + 1 & 7] << 13;\n                }\n            }\n            // Enforce an array length of 8, not all zeroes.\n            while(X.length < 8)X.push(0);\n            for(j = 0; j < 8 && X[j] === 0; ++j);\n            if (j == 8) w = X[7] = -1;\n            else w = X[j];\n            me.x = X;\n            me.i = 0;\n            // Discard an initial 256 values.\n            for(j = 256; j > 0; --j){\n                me.next();\n            }\n        }\n        init(me, seed);\n    }\n    function copy(f, t) {\n        t.x = f.x.slice();\n        t.i = f.i;\n        return t;\n    }\n    function impl(seed, opts) {\n        if (seed == null) seed = +new Date;\n        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {\n            return (xg.next() >>> 0) / 0x100000000;\n        };\n        prng.double = function() {\n            do {\n                var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / (1 << 21);\n            }while (result === 0);\n            return result;\n        };\n        prng.int32 = xg.next;\n        prng.quick = prng;\n        if (state) {\n            if (state.x) copy(state, xg);\n            prng.state = function() {\n                return copy(xg, {});\n            };\n        }\n        return prng;\n    }\n    if (module1 && module1.exports) {\n        module1.exports = impl;\n    } else if (__webpack_require__.amdD && __webpack_require__.amdO) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return impl;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {\n        this.xorshift7 = impl;\n    }\n})(this,  true && module, __webpack_require__.amdD // present with an AMD loader\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yc2hpZnQ3LmpzIiwibWFwcGluZ3MiOiI7QUFBQSwrRkFBNkQ7QUFDN0QseUNBQXlDO0FBQ3pDLDhDQUE4QztBQUM5QywwRUFBMEU7QUFFekUsVUFBU0EsTUFBTSxFQUFFQyxPQUFNLEVBQUVDLE9BQU07SUFFaEMsU0FBU0MsT0FBT0MsSUFBSTtRQUNsQixJQUFJQyxLQUFLLElBQUk7UUFFYiw2QkFBNkI7UUFDN0JBLEdBQUdDLElBQUksR0FBRztZQUNSLHdCQUF3QjtZQUN4QixJQUFJQyxJQUFJRixHQUFHRyxDQUFDLEVBQUVDLElBQUlKLEdBQUdJLENBQUMsRUFBRUMsR0FBR0MsR0FBR0M7WUFDOUJGLElBQUlILENBQUMsQ0FBQ0UsRUFBRTtZQUFFQyxLQUFNQSxNQUFNO1lBQUlDLElBQUlELElBQUtBLEtBQUs7WUFDeENBLElBQUlILENBQUMsQ0FBQyxJQUFLLElBQUssRUFBRTtZQUFFSSxLQUFLRCxJQUFLQSxNQUFNO1lBQ3BDQSxJQUFJSCxDQUFDLENBQUMsSUFBSyxJQUFLLEVBQUU7WUFBRUksS0FBS0QsSUFBS0EsTUFBTTtZQUNwQ0EsSUFBSUgsQ0FBQyxDQUFDLElBQUssSUFBSyxFQUFFO1lBQUVJLEtBQUtELElBQUtBLEtBQUs7WUFDbkNBLElBQUlILENBQUMsQ0FBQyxJQUFLLElBQUssRUFBRTtZQUFFRyxJQUFJQSxJQUFLQSxLQUFLO1lBQUtDLEtBQUtELElBQUtBLEtBQUs7WUFDdERILENBQUMsQ0FBQ0UsRUFBRSxHQUFHRTtZQUNQTixHQUFHSSxDQUFDLEdBQUcsSUFBSyxJQUFLO1lBQ2pCLE9BQU9FO1FBQ1Q7UUFFQSxTQUFTRSxLQUFLUixFQUFFLEVBQUVELElBQUk7WUFDcEIsSUFBSVUsR0FBR0YsR0FBR0wsSUFBSSxFQUFFO1lBRWhCLElBQUlILFNBQVVBLENBQUFBLE9BQU8sSUFBSTtnQkFDdkIsMkNBQTJDO2dCQUMzQ1EsSUFBSUwsQ0FBQyxDQUFDLEVBQUUsR0FBR0g7WUFDYixPQUFPO2dCQUNMLDZCQUE2QjtnQkFDN0JBLE9BQU8sS0FBS0E7Z0JBQ1osSUFBS1UsSUFBSSxHQUFHQSxJQUFJVixLQUFLVyxNQUFNLEVBQUUsRUFBRUQsRUFBRztvQkFDaENQLENBQUMsQ0FBQ08sSUFBSSxFQUFFLEdBQUcsQ0FBRSxDQUFDQSxJQUFJLEVBQUUsSUFBSSxLQUNuQlYsS0FBS1ksVUFBVSxDQUFDRixLQUFLUCxDQUFDLENBQUMsSUFBSyxJQUFLLEVBQUUsSUFBSTtnQkFDOUM7WUFDRjtZQUNBLGdEQUFnRDtZQUNoRCxNQUFPQSxFQUFFUSxNQUFNLEdBQUcsRUFBR1IsRUFBRVUsSUFBSSxDQUFDO1lBQzVCLElBQUtILElBQUksR0FBR0EsSUFBSSxLQUFLUCxDQUFDLENBQUNPLEVBQUUsS0FBSyxHQUFHLEVBQUVBO1lBQ25DLElBQUlBLEtBQUssR0FBR0YsSUFBSUwsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDO2lCQUFRSyxJQUFJTCxDQUFDLENBQUNPLEVBQUU7WUFFeENULEdBQUdHLENBQUMsR0FBR0Q7WUFDUEYsR0FBR0ksQ0FBQyxHQUFHO1lBRVAsaUNBQWlDO1lBQ2pDLElBQUtLLElBQUksS0FBS0EsSUFBSSxHQUFHLEVBQUVBLEVBQUc7Z0JBQ3hCVCxHQUFHQyxJQUFJO1lBQ1Q7UUFDRjtRQUVBTyxLQUFLUixJQUFJRDtJQUNYO0lBRUEsU0FBU2MsS0FBS0MsQ0FBQyxFQUFFVCxDQUFDO1FBQ2hCQSxFQUFFRixDQUFDLEdBQUdXLEVBQUVYLENBQUMsQ0FBQ1ksS0FBSztRQUNmVixFQUFFRCxDQUFDLEdBQUdVLEVBQUVWLENBQUM7UUFDVCxPQUFPQztJQUNUO0lBRUEsU0FBU1csS0FBS2pCLElBQUksRUFBRWtCLElBQUk7UUFDdEIsSUFBSWxCLFFBQVEsTUFBTUEsT0FBTyxDQUFFLElBQUltQjtRQUMvQixJQUFJQyxLQUFLLElBQUlyQixPQUFPQyxPQUNoQnFCLFFBQVFILFFBQVFBLEtBQUtHLEtBQUssRUFDMUJDLE9BQU87WUFBYSxPQUFPLENBQUNGLEdBQUdsQixJQUFJLE9BQU8sS0FBSztRQUFhO1FBQ2hFb0IsS0FBS0MsTUFBTSxHQUFHO1lBQ1osR0FBRztnQkFDRCxJQUFJQyxNQUFNSixHQUFHbEIsSUFBSSxPQUFPLElBQ3BCdUIsTUFBTSxDQUFDTCxHQUFHbEIsSUFBSSxPQUFPLEtBQUssYUFDMUJ3QixTQUFTLENBQUNGLE1BQU1DLEdBQUUsSUFBTSxNQUFLLEVBQUM7WUFDcEMsUUFBU0MsV0FBVyxHQUFHO1lBQ3ZCLE9BQU9BO1FBQ1Q7UUFDQUosS0FBS0ssS0FBSyxHQUFHUCxHQUFHbEIsSUFBSTtRQUNwQm9CLEtBQUtNLEtBQUssR0FBR047UUFDYixJQUFJRCxPQUFPO1lBQ1QsSUFBSUEsTUFBTWpCLENBQUMsRUFBRVUsS0FBS08sT0FBT0Q7WUFDekJFLEtBQUtELEtBQUssR0FBRztnQkFBYSxPQUFPUCxLQUFLTSxJQUFJLENBQUM7WUFBSTtRQUNqRDtRQUNBLE9BQU9FO0lBQ1Q7SUFFQSxJQUFJekIsV0FBVUEsUUFBT2dDLE9BQU8sRUFBRTtRQUM1QmhDLFFBQU9nQyxPQUFPLEdBQUdaO0lBQ25CLE9BQU8sSUFBSW5CLHdCQUFBQSxJQUFVQSx3QkFBVSxFQUFFO1FBQy9CQSxtQ0FBTztZQUFhLE9BQU9tQjtRQUFNLENBQUM7QUFBQSxrR0FBQztJQUNyQyxPQUFPO1FBQ0wsSUFBSSxDQUFDYyxTQUFTLEdBQUdkO0lBQ25CO0FBRUEsR0FDRSxJQUFJLEVBQ0osS0FBbUIsSUFBWXBCLFFBQy9CLHdCQUF1Q0MsQ0FBRyw2QkFBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly95b2dhcG9zZXBlcmZlY3QvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yc2hpZnQ3LmpzPzdlYmEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwieG9yc2hpZnQ3XCIgYWxnb3JpdGhtIGJ5XG4vLyBGcmFuw6dvaXMgUGFubmV0b24gYW5kIFBpZXJyZSBMJ2VjdXllcjpcbi8vIFwiT24gdGhlIFhvcmdzaGlmdCBSYW5kb20gTnVtYmVyIEdlbmVyYXRvcnNcIlxuLy8gaHR0cDovL3NhbHVjLmVuZ3IudWNvbm4uZWR1L3JlZnMvY3J5cHRvL3JuZy9wYW5uZXRvbjA1b250aGV4b3JzaGlmdC5wZGZcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gVXBkYXRlIHhvciBnZW5lcmF0b3IuXG4gICAgdmFyIFggPSBtZS54LCBpID0gbWUuaSwgdCwgdiwgdztcbiAgICB0ID0gWFtpXTsgdCBePSAodCA+Pj4gNyk7IHYgPSB0IF4gKHQgPDwgMjQpO1xuICAgIHQgPSBYWyhpICsgMSkgJiA3XTsgdiBePSB0IF4gKHQgPj4+IDEwKTtcbiAgICB0ID0gWFsoaSArIDMpICYgN107IHYgXj0gdCBeICh0ID4+PiAzKTtcbiAgICB0ID0gWFsoaSArIDQpICYgN107IHYgXj0gdCBeICh0IDw8IDcpO1xuICAgIHQgPSBYWyhpICsgNykgJiA3XTsgdCA9IHQgXiAodCA8PCAxMyk7IHYgXj0gdCBeICh0IDw8IDkpO1xuICAgIFhbaV0gPSB2O1xuICAgIG1lLmkgPSAoaSArIDEpICYgNztcbiAgICByZXR1cm4gdjtcbiAgfTtcblxuICBmdW5jdGlvbiBpbml0KG1lLCBzZWVkKSB7XG4gICAgdmFyIGosIHcsIFggPSBbXTtcblxuICAgIGlmIChzZWVkID09PSAoc2VlZCB8IDApKSB7XG4gICAgICAvLyBTZWVkIHN0YXRlIGFycmF5IHVzaW5nIGEgMzItYml0IGludGVnZXIuXG4gICAgICB3ID0gWFswXSA9IHNlZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNlZWQgc3RhdGUgdXNpbmcgYSBzdHJpbmcuXG4gICAgICBzZWVkID0gJycgKyBzZWVkO1xuICAgICAgZm9yIChqID0gMDsgaiA8IHNlZWQubGVuZ3RoOyArK2opIHtcbiAgICAgICAgWFtqICYgN10gPSAoWFtqICYgN10gPDwgMTUpIF5cbiAgICAgICAgICAgIChzZWVkLmNoYXJDb2RlQXQoaikgKyBYWyhqICsgMSkgJiA3XSA8PCAxMyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEVuZm9yY2UgYW4gYXJyYXkgbGVuZ3RoIG9mIDgsIG5vdCBhbGwgemVyb2VzLlxuICAgIHdoaWxlIChYLmxlbmd0aCA8IDgpIFgucHVzaCgwKTtcbiAgICBmb3IgKGogPSAwOyBqIDwgOCAmJiBYW2pdID09PSAwOyArK2opO1xuICAgIGlmIChqID09IDgpIHcgPSBYWzddID0gLTE7IGVsc2UgdyA9IFhbal07XG5cbiAgICBtZS54ID0gWDtcbiAgICBtZS5pID0gMDtcblxuICAgIC8vIERpc2NhcmQgYW4gaW5pdGlhbCAyNTYgdmFsdWVzLlxuICAgIGZvciAoaiA9IDI1NjsgaiA+IDA7IC0taikge1xuICAgICAgbWUubmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIGluaXQobWUsIHNlZWQpO1xufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC54ID0gZi54LnNsaWNlKCk7XG4gIHQuaSA9IGYuaTtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICBpZiAoc2VlZCA9PSBudWxsKSBzZWVkID0gKyhuZXcgRGF0ZSk7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlLngpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3JzaGlmdDcgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwibW9kdWxlIiwiZGVmaW5lIiwiWG9yR2VuIiwic2VlZCIsIm1lIiwibmV4dCIsIlgiLCJ4IiwiaSIsInQiLCJ2IiwidyIsImluaXQiLCJqIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsInB1c2giLCJjb3B5IiwiZiIsInNsaWNlIiwiaW1wbCIsIm9wdHMiLCJEYXRlIiwieGciLCJzdGF0ZSIsInBybmciLCJkb3VibGUiLCJ0b3AiLCJib3QiLCJyZXN1bHQiLCJpbnQzMiIsInF1aWNrIiwiZXhwb3J0cyIsImFtZCIsInhvcnNoaWZ0NyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/seedrandom/lib/xorshift7.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/seedrandom/lib/xorwow.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/xorwow.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the \"xorwow\" prng algorithm by\n// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper\n(function(global, module1, define1) {\n    function XorGen(seed) {\n        var me = this, strseed = \"\";\n        // Set up generator function.\n        me.next = function() {\n            var t = me.x ^ me.x >>> 2;\n            me.x = me.y;\n            me.y = me.z;\n            me.z = me.w;\n            me.w = me.v;\n            return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;\n        };\n        me.x = 0;\n        me.y = 0;\n        me.z = 0;\n        me.w = 0;\n        me.v = 0;\n        if (seed === (seed | 0)) {\n            // Integer seed.\n            me.x = seed;\n        } else {\n            // String seed.\n            strseed += seed;\n        }\n        // Mix in string seed, then discard an initial batch of 64 values.\n        for(var k = 0; k < strseed.length + 64; k++){\n            me.x ^= strseed.charCodeAt(k) | 0;\n            if (k == strseed.length) {\n                me.d = me.x << 10 ^ me.x >>> 4;\n            }\n            me.next();\n        }\n    }\n    function copy(f, t) {\n        t.x = f.x;\n        t.y = f.y;\n        t.z = f.z;\n        t.w = f.w;\n        t.v = f.v;\n        t.d = f.d;\n        return t;\n    }\n    function impl(seed, opts) {\n        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {\n            return (xg.next() >>> 0) / 0x100000000;\n        };\n        prng.double = function() {\n            do {\n                var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 0x100000000, result = (top + bot) / (1 << 21);\n            }while (result === 0);\n            return result;\n        };\n        prng.int32 = xg.next;\n        prng.quick = prng;\n        if (state) {\n            if (typeof state == \"object\") copy(state, xg);\n            prng.state = function() {\n                return copy(xg, {});\n            };\n        }\n        return prng;\n    }\n    if (module1 && module1.exports) {\n        module1.exports = impl;\n    } else if (__webpack_require__.amdD && __webpack_require__.amdO) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return impl;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {\n        this.xorwow = impl;\n    }\n})(this,  true && module, __webpack_require__.amdD // present with an AMD loader\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yd293LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxpR0FBK0Q7QUFDL0QsZ0VBQWdFO0FBRS9ELFVBQVNBLE1BQU0sRUFBRUMsT0FBTSxFQUFFQyxPQUFNO0lBRWhDLFNBQVNDLE9BQU9DLElBQUk7UUFDbEIsSUFBSUMsS0FBSyxJQUFJLEVBQUVDLFVBQVU7UUFFekIsNkJBQTZCO1FBQzdCRCxHQUFHRSxJQUFJLEdBQUc7WUFDUixJQUFJQyxJQUFLSCxHQUFHSSxDQUFDLEdBQUlKLEdBQUdJLENBQUMsS0FBSztZQUMxQkosR0FBR0ksQ0FBQyxHQUFHSixHQUFHSyxDQUFDO1lBQUVMLEdBQUdLLENBQUMsR0FBR0wsR0FBR00sQ0FBQztZQUFFTixHQUFHTSxDQUFDLEdBQUdOLEdBQUdPLENBQUM7WUFBRVAsR0FBR08sQ0FBQyxHQUFHUCxHQUFHUSxDQUFDO1lBQ2xELE9BQU8sQ0FBQ1IsR0FBR1MsQ0FBQyxHQUFJVCxHQUFHUyxDQUFDLEdBQUcsU0FBUyxDQUFDLElBQzdCVCxDQUFBQSxHQUFHUSxDQUFDLEdBQUcsR0FBSUEsQ0FBQyxHQUFJUixHQUFHUSxDQUFDLElBQUksSUFBT0wsQ0FBQUEsSUFBS0EsS0FBSyxDQUFDLENBQUMsSUFBSztRQUN0RDtRQUVBSCxHQUFHSSxDQUFDLEdBQUc7UUFDUEosR0FBR0ssQ0FBQyxHQUFHO1FBQ1BMLEdBQUdNLENBQUMsR0FBRztRQUNQTixHQUFHTyxDQUFDLEdBQUc7UUFDUFAsR0FBR1EsQ0FBQyxHQUFHO1FBRVAsSUFBSVQsU0FBVUEsQ0FBQUEsT0FBTyxJQUFJO1lBQ3ZCLGdCQUFnQjtZQUNoQkMsR0FBR0ksQ0FBQyxHQUFHTDtRQUNULE9BQU87WUFDTCxlQUFlO1lBQ2ZFLFdBQVdGO1FBQ2I7UUFFQSxrRUFBa0U7UUFDbEUsSUFBSyxJQUFJVyxJQUFJLEdBQUdBLElBQUlULFFBQVFVLE1BQU0sR0FBRyxJQUFJRCxJQUFLO1lBQzVDVixHQUFHSSxDQUFDLElBQUlILFFBQVFXLFVBQVUsQ0FBQ0YsS0FBSztZQUNoQyxJQUFJQSxLQUFLVCxRQUFRVSxNQUFNLEVBQUU7Z0JBQ3ZCWCxHQUFHUyxDQUFDLEdBQUdULEdBQUdJLENBQUMsSUFBSSxLQUFLSixHQUFHSSxDQUFDLEtBQUs7WUFDL0I7WUFDQUosR0FBR0UsSUFBSTtRQUNUO0lBQ0Y7SUFFQSxTQUFTVyxLQUFLQyxDQUFDLEVBQUVYLENBQUM7UUFDaEJBLEVBQUVDLENBQUMsR0FBR1UsRUFBRVYsQ0FBQztRQUNURCxFQUFFRSxDQUFDLEdBQUdTLEVBQUVULENBQUM7UUFDVEYsRUFBRUcsQ0FBQyxHQUFHUSxFQUFFUixDQUFDO1FBQ1RILEVBQUVJLENBQUMsR0FBR08sRUFBRVAsQ0FBQztRQUNUSixFQUFFSyxDQUFDLEdBQUdNLEVBQUVOLENBQUM7UUFDVEwsRUFBRU0sQ0FBQyxHQUFHSyxFQUFFTCxDQUFDO1FBQ1QsT0FBT047SUFDVDtJQUVBLFNBQVNZLEtBQUtoQixJQUFJLEVBQUVpQixJQUFJO1FBQ3RCLElBQUlDLEtBQUssSUFBSW5CLE9BQU9DLE9BQ2hCbUIsUUFBUUYsUUFBUUEsS0FBS0UsS0FBSyxFQUMxQkMsT0FBTztZQUFhLE9BQU8sQ0FBQ0YsR0FBR2YsSUFBSSxPQUFPLEtBQUs7UUFBYTtRQUNoRWlCLEtBQUtDLE1BQU0sR0FBRztZQUNaLEdBQUc7Z0JBQ0QsSUFBSUMsTUFBTUosR0FBR2YsSUFBSSxPQUFPLElBQ3BCb0IsTUFBTSxDQUFDTCxHQUFHZixJQUFJLE9BQU8sS0FBSyxhQUMxQnFCLFNBQVMsQ0FBQ0YsTUFBTUMsR0FBRSxJQUFNLE1BQUssRUFBQztZQUNwQyxRQUFTQyxXQUFXLEdBQUc7WUFDdkIsT0FBT0E7UUFDVDtRQUNBSixLQUFLSyxLQUFLLEdBQUdQLEdBQUdmLElBQUk7UUFDcEJpQixLQUFLTSxLQUFLLEdBQUdOO1FBQ2IsSUFBSUQsT0FBTztZQUNULElBQUksT0FBT0EsU0FBVSxVQUFVTCxLQUFLSyxPQUFPRDtZQUMzQ0UsS0FBS0QsS0FBSyxHQUFHO2dCQUFhLE9BQU9MLEtBQUtJLElBQUksQ0FBQztZQUFJO1FBQ2pEO1FBQ0EsT0FBT0U7SUFDVDtJQUVBLElBQUl2QixXQUFVQSxRQUFPOEIsT0FBTyxFQUFFO1FBQzVCOUIsUUFBTzhCLE9BQU8sR0FBR1g7SUFDbkIsT0FBTyxJQUFJbEIsd0JBQUFBLElBQVVBLHdCQUFVLEVBQUU7UUFDL0JBLG1DQUFPO1lBQWEsT0FBT2tCO1FBQU0sQ0FBQztBQUFBLGtHQUFDO0lBQ3JDLE9BQU87UUFDTCxJQUFJLENBQUNhLE1BQU0sR0FBR2I7SUFDaEI7QUFFQSxHQUNFLElBQUksRUFDSixLQUFtQixJQUFZbkIsUUFDL0Isd0JBQXVDQyxDQUFHLDZCQUE2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3lvZ2Fwb3NlcGVyZmVjdC8uL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi94b3J3b3cuanM/ZWMxMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBIEphdmFzY3JpcHQgaW1wbGVtZW50YWlvbiBvZiB0aGUgXCJ4b3J3b3dcIiBwcm5nIGFsZ29yaXRobSBieVxuLy8gR2VvcmdlIE1hcnNhZ2xpYS4gIFNlZSBodHRwOi8vd3d3LmpzdGF0c29mdC5vcmcvdjA4L2kxNC9wYXBlclxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzLCBzdHJzZWVkID0gJyc7XG5cbiAgLy8gU2V0IHVwIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gKG1lLnggXiAobWUueCA+Pj4gMikpO1xuICAgIG1lLnggPSBtZS55OyBtZS55ID0gbWUuejsgbWUueiA9IG1lLnc7IG1lLncgPSBtZS52O1xuICAgIHJldHVybiAobWUuZCA9IChtZS5kICsgMzYyNDM3IHwgMCkpICtcbiAgICAgICAobWUudiA9IChtZS52IF4gKG1lLnYgPDwgNCkpIF4gKHQgXiAodCA8PCAxKSkpIHwgMDtcbiAgfTtcblxuICBtZS54ID0gMDtcbiAgbWUueSA9IDA7XG4gIG1lLnogPSAwO1xuICBtZS53ID0gMDtcbiAgbWUudiA9IDA7XG5cbiAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAvLyBJbnRlZ2VyIHNlZWQuXG4gICAgbWUueCA9IHNlZWQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RyaW5nIHNlZWQuXG4gICAgc3Ryc2VlZCArPSBzZWVkO1xuICB9XG5cbiAgLy8gTWl4IGluIHN0cmluZyBzZWVkLCB0aGVuIGRpc2NhcmQgYW4gaW5pdGlhbCBiYXRjaCBvZiA2NCB2YWx1ZXMuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgc3Ryc2VlZC5sZW5ndGggKyA2NDsgaysrKSB7XG4gICAgbWUueCBePSBzdHJzZWVkLmNoYXJDb2RlQXQoaykgfCAwO1xuICAgIGlmIChrID09IHN0cnNlZWQubGVuZ3RoKSB7XG4gICAgICBtZS5kID0gbWUueCA8PCAxMCBeIG1lLnggPj4+IDQ7XG4gICAgfVxuICAgIG1lLm5leHQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC54ID0gZi54O1xuICB0LnkgPSBmLnk7XG4gIHQueiA9IGYuejtcbiAgdC53ID0gZi53O1xuICB0LnYgPSBmLnY7XG4gIHQuZCA9IGYuZDtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGltcGwoc2VlZCwgb3B0cykge1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Yoc3RhdGUpID09ICdvYmplY3QnKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMueG9yd293ID0gaW1wbDtcbn1cblxufSkoXG4gIHRoaXMsXG4gICh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUsICAgIC8vIHByZXNlbnQgaW4gbm9kZS5qc1xuICAodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUgICAvLyBwcmVzZW50IHdpdGggYW4gQU1EIGxvYWRlclxuKTtcblxuXG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwibW9kdWxlIiwiZGVmaW5lIiwiWG9yR2VuIiwic2VlZCIsIm1lIiwic3Ryc2VlZCIsIm5leHQiLCJ0IiwieCIsInkiLCJ6IiwidyIsInYiLCJkIiwiayIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJjb3B5IiwiZiIsImltcGwiLCJvcHRzIiwieGciLCJzdGF0ZSIsInBybmciLCJkb3VibGUiLCJ0b3AiLCJib3QiLCJyZXN1bHQiLCJpbnQzMiIsInF1aWNrIiwiZXhwb3J0cyIsImFtZCIsInhvcndvdyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/seedrandom/lib/xorwow.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/seedrandom/seedrandom.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/seedrandom.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("var __WEBPACK_AMD_DEFINE_RESULT__;\n/*\nCopyright 2019 David Bau.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/ (function(global, pool, math) {\n    //\n    // The following constants are related to IEEE 754 limits.\n    //\n    var width = 256, chunks = 6, digits = 52, rngname = \"random\", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto; // node.js crypto module, initialized at the bottom.\n    //\n    // seedrandom()\n    // This is the seedrandom function described above.\n    //\n    function seedrandom(seed, options, callback) {\n        var key = [];\n        options = options == true ? {\n            entropy: true\n        } : options || {};\n        // Flatten the seed string or build one from local entropy if needed.\n        var shortseed = mixkey(flatten(options.entropy ? [\n            seed,\n            tostring(pool)\n        ] : seed == null ? autoseed() : seed, 3), key);\n        // Use the seed to initialize an ARC4 generator.\n        var arc4 = new ARC4(key);\n        // This function returns a random double in [0, 1) that contains\n        // randomness in every bit of the mantissa of the IEEE 754 value.\n        var prng = function() {\n            var n = arc4.g(chunks), d = startdenom, x = 0; //   and no 'extra last byte'.\n            while(n < significance){\n                n = (n + x) * width; //   shifting numerator and\n                d *= width; //   denominator and generating a\n                x = arc4.g(1); //   new least-significant-byte.\n            }\n            while(n >= overflow){\n                n /= 2; //   last byte, shift everything\n                d /= 2; //   right using integer math until\n                x >>>= 1; //   we have exactly the desired bits.\n            }\n            return (n + x) / d; // Form the number within [0, 1).\n        };\n        prng.int32 = function() {\n            return arc4.g(4) | 0;\n        };\n        prng.quick = function() {\n            return arc4.g(4) / 0x100000000;\n        };\n        prng.double = prng;\n        // Mix the randomness into accumulated entropy.\n        mixkey(tostring(arc4.S), pool);\n        // Calling convention: what to return as a function of prng, seed, is_math.\n        return (options.pass || callback || function(prng, seed, is_math_call, state) {\n            if (state) {\n                // Load the arc4 state from the given state if it has an S array.\n                if (state.S) {\n                    copy(state, arc4);\n                }\n                // Only provide the .state method if requested via options.state.\n                prng.state = function() {\n                    return copy(arc4, {});\n                };\n            }\n            // If called as a method of Math (Math.seedrandom()), mutate\n            // Math.random because that is how seedrandom.js has worked since v1.0.\n            if (is_math_call) {\n                math[rngname] = prng;\n                return seed;\n            } else return prng;\n        })(prng, shortseed, \"global\" in options ? options.global : this == math, options.state);\n    }\n    //\n    // ARC4\n    //\n    // An ARC4 implementation.  The constructor takes a key in the form of\n    // an array of at most (width) integers that should be 0 <= x < (width).\n    //\n    // The g(count) method returns a pseudorandom integer that concatenates\n    // the next (count) outputs from ARC4.  Its return value is a number x\n    // that is in the range 0 <= x < (width ^ count).\n    //\n    function ARC4(key) {\n        var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];\n        // The empty key [] is treated as [0].\n        if (!keylen) {\n            key = [\n                keylen++\n            ];\n        }\n        // Set up S using the standard key scheduling algorithm.\n        while(i < width){\n            s[i] = i++;\n        }\n        for(i = 0; i < width; i++){\n            s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];\n            s[j] = t;\n        }\n        // The \"g\" method returns the next (count) outputs as one number.\n        (me.g = function(count) {\n            // Using instance members instead of closure state nearly doubles speed.\n            var t, r = 0, i = me.i, j = me.j, s = me.S;\n            while(count--){\n                t = s[i = mask & i + 1];\n                r = r * width + s[mask & (s[i] = s[j = mask & j + t]) + (s[j] = t)];\n            }\n            me.i = i;\n            me.j = j;\n            return r;\n        // For robust unpredictability, the function call below automatically\n        // discards an initial batch of values.  This is called RC4-drop[256].\n        // See http://google.com/search?q=rsa+fluhrer+response&btnI\n        })(width);\n    }\n    //\n    // copy()\n    // Copies internal state of ARC4 to or from a plain object.\n    //\n    function copy(f, t) {\n        t.i = f.i;\n        t.j = f.j;\n        t.S = f.S.slice();\n        return t;\n    }\n    ;\n    //\n    // flatten()\n    // Converts an object tree to nested arrays of strings.\n    //\n    function flatten(obj, depth) {\n        var result = [], typ = typeof obj, prop;\n        if (depth && typ == \"object\") {\n            for(prop in obj){\n                try {\n                    result.push(flatten(obj[prop], depth - 1));\n                } catch (e) {}\n            }\n        }\n        return result.length ? result : typ == \"string\" ? obj : obj + \"\\x00\";\n    }\n    //\n    // mixkey()\n    // Mixes a string seed into a key that is an array of integers, and\n    // returns a shortened string seed that is equivalent to the result key.\n    //\n    function mixkey(seed, key) {\n        var stringseed = seed + \"\", smear, j = 0;\n        while(j < stringseed.length){\n            key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);\n        }\n        return tostring(key);\n    }\n    //\n    // autoseed()\n    // Returns an object for autoseeding, using window.crypto and Node crypto\n    // module if available.\n    //\n    function autoseed() {\n        try {\n            var out;\n            if (nodecrypto && (out = nodecrypto.randomBytes)) {\n                // The use of 'out' to remember randomBytes makes tight minified code.\n                out = out(width);\n            } else {\n                out = new Uint8Array(width);\n                (global.crypto || global.msCrypto).getRandomValues(out);\n            }\n            return tostring(out);\n        } catch (e) {\n            var browser = global.navigator, plugins = browser && browser.plugins;\n            return [\n                +new Date,\n                global,\n                plugins,\n                global.screen,\n                tostring(pool)\n            ];\n        }\n    }\n    //\n    // tostring()\n    // Converts an array of charcodes to a string\n    //\n    function tostring(a) {\n        return String.fromCharCode.apply(0, a);\n    }\n    //\n    // When seedrandom.js is loaded, we immediately mix a few bits\n    // from the built-in RNG into the entropy pool.  Because we do\n    // not want to interfere with deterministic PRNG state later,\n    // seedrandom will not call math.random on its own again after\n    // initialization.\n    //\n    mixkey(math.random(), pool);\n    //\n    // Nodejs and AMD support: export the implementation as a module using\n    // either convention.\n    //\n    if ( true && module.exports) {\n        module.exports = seedrandom;\n        // When in node.js, try using crypto package for autoseeding.\n        try {\n            nodecrypto = __webpack_require__(/*! crypto */ \"crypto\");\n        } catch (ex) {}\n    } else if (true) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return seedrandom;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n// End anonymous scope, and pass initial values.\n})(// global: `self` in browsers (including strict mode and web workers),\n// otherwise `this` in Node and other environments\ntypeof self !== \"undefined\" ? self : void 0, [], Math // math: package containing random, pow, and seedrandom\n);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9zZWVkcmFuZG9tLmpzIiwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQSxHQUVDLFVBQVVBLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxJQUFJO0lBQzdCLEVBQUU7SUFDRiwwREFBMEQ7SUFDMUQsRUFBRTtJQUVGLElBQUlDLFFBQVEsS0FDUkMsU0FBUyxHQUNUQyxTQUFTLElBQ1RDLFVBQVUsVUFDVkMsYUFBYUwsS0FBS00sR0FBRyxDQUFDTCxPQUFPQyxTQUM3QkssZUFBZVAsS0FBS00sR0FBRyxDQUFDLEdBQUdILFNBQzNCSyxXQUFXRCxlQUFlLEdBQzFCRSxPQUFPUixRQUFRLEdBQ2ZTLFlBQW9CLG9EQUFvRDtJQUU1RSxFQUFFO0lBQ0YsZUFBZTtJQUNmLG1EQUFtRDtJQUNuRCxFQUFFO0lBQ0YsU0FBU0MsV0FBV0MsSUFBSSxFQUFFQyxPQUFPLEVBQUVDLFFBQVE7UUFDekMsSUFBSUMsTUFBTSxFQUFFO1FBQ1pGLFVBQVUsV0FBWSxPQUFRO1lBQUVHLFNBQVM7UUFBSyxJQUFLSCxXQUFXLENBQUM7UUFFL0QscUVBQXFFO1FBQ3JFLElBQUlJLFlBQVlDLE9BQU9DLFFBQ3JCTixRQUFRRyxPQUFPLEdBQUc7WUFBQ0o7WUFBTVEsU0FBU3JCO1NBQU0sR0FDeEMsUUFBUyxPQUFRc0IsYUFBYVQsTUFBTSxJQUFJRztRQUUxQyxnREFBZ0Q7UUFDaEQsSUFBSU8sT0FBTyxJQUFJQyxLQUFLUjtRQUVwQixnRUFBZ0U7UUFDaEUsaUVBQWlFO1FBQ2pFLElBQUlTLE9BQU87WUFDVCxJQUFJQyxJQUFJSCxLQUFLSSxDQUFDLENBQUN4QixTQUNYeUIsSUFBSXRCLFlBQ0p1QixJQUFJLEdBQTRCLDhCQUE4QjtZQUNsRSxNQUFPSCxJQUFJbEIsYUFBYztnQkFDdkJrQixJQUFJLENBQUNBLElBQUlHLENBQUFBLElBQUszQixPQUFvQiwyQkFBMkI7Z0JBQzdEMEIsS0FBSzFCLE9BQTZCLGlDQUFpQztnQkFDbkUyQixJQUFJTixLQUFLSSxDQUFDLENBQUMsSUFBdUIsZ0NBQWdDO1lBQ3BFO1lBQ0EsTUFBT0QsS0FBS2pCLFNBQVU7Z0JBQ3BCaUIsS0FBSyxHQUE2QixnQ0FBZ0M7Z0JBQ2xFRSxLQUFLLEdBQTZCLG1DQUFtQztnQkFDckVDLE9BQU8sR0FBMkIsc0NBQXNDO1lBQzFFO1lBQ0EsT0FBTyxDQUFDSCxJQUFJRyxDQUFBQSxJQUFLRCxHQUFtQixpQ0FBaUM7UUFDdkU7UUFFQUgsS0FBS0ssS0FBSyxHQUFHO1lBQWEsT0FBT1AsS0FBS0ksQ0FBQyxDQUFDLEtBQUs7UUFBRztRQUNoREYsS0FBS00sS0FBSyxHQUFHO1lBQWEsT0FBT1IsS0FBS0ksQ0FBQyxDQUFDLEtBQUs7UUFBYTtRQUMxREYsS0FBS08sTUFBTSxHQUFHUDtRQUVkLCtDQUErQztRQUMvQ04sT0FBT0UsU0FBU0UsS0FBS1UsQ0FBQyxHQUFHakM7UUFFekIsMkVBQTJFO1FBQzNFLE9BQU8sQ0FBQ2MsUUFBUW9CLElBQUksSUFBSW5CLFlBQ3BCLFNBQVNVLElBQUksRUFBRVosSUFBSSxFQUFFc0IsWUFBWSxFQUFFQyxLQUFLO1lBQ3RDLElBQUlBLE9BQU87Z0JBQ1QsaUVBQWlFO2dCQUNqRSxJQUFJQSxNQUFNSCxDQUFDLEVBQUU7b0JBQUVJLEtBQUtELE9BQU9iO2dCQUFPO2dCQUNsQyxpRUFBaUU7Z0JBQ2pFRSxLQUFLVyxLQUFLLEdBQUc7b0JBQWEsT0FBT0MsS0FBS2QsTUFBTSxDQUFDO2dCQUFJO1lBQ25EO1lBRUEsNERBQTREO1lBQzVELHVFQUF1RTtZQUN2RSxJQUFJWSxjQUFjO2dCQUFFbEMsSUFBSSxDQUFDSSxRQUFRLEdBQUdvQjtnQkFBTSxPQUFPWjtZQUFNLE9BSWxELE9BQU9ZO1FBQ2QsR0FDSkEsTUFDQVAsV0FDQSxZQUFZSixVQUFVQSxRQUFRZixNQUFNLEdBQUksSUFBSSxJQUFJRSxNQUNoRGEsUUFBUXNCLEtBQUs7SUFDZjtJQUVBLEVBQUU7SUFDRixPQUFPO0lBQ1AsRUFBRTtJQUNGLHNFQUFzRTtJQUN0RSx3RUFBd0U7SUFDeEUsRUFBRTtJQUNGLHVFQUF1RTtJQUN2RSxzRUFBc0U7SUFDdEUsaURBQWlEO0lBQ2pELEVBQUU7SUFDRixTQUFTWixLQUFLUixHQUFHO1FBQ2YsSUFBSXNCLEdBQUdDLFNBQVN2QixJQUFJd0IsTUFBTSxFQUN0QkMsS0FBSyxJQUFJLEVBQUVDLElBQUksR0FBR0MsSUFBSUYsR0FBR0MsQ0FBQyxHQUFHRCxHQUFHRSxDQUFDLEdBQUcsR0FBR0MsSUFBSUgsR0FBR1IsQ0FBQyxHQUFHLEVBQUU7UUFFeEQsc0NBQXNDO1FBQ3RDLElBQUksQ0FBQ00sUUFBUTtZQUFFdkIsTUFBTTtnQkFBQ3VCO2FBQVM7UUFBRTtRQUVqQyx3REFBd0Q7UUFDeEQsTUFBT0csSUFBSXhDLE1BQU87WUFDaEIwQyxDQUFDLENBQUNGLEVBQUUsR0FBR0E7UUFDVDtRQUNBLElBQUtBLElBQUksR0FBR0EsSUFBSXhDLE9BQU93QyxJQUFLO1lBQzFCRSxDQUFDLENBQUNGLEVBQUUsR0FBR0UsQ0FBQyxDQUFDRCxJQUFJakMsT0FBUWlDLElBQUkzQixHQUFHLENBQUMwQixJQUFJSCxPQUFPLEdBQUlELENBQUFBLElBQUlNLENBQUMsQ0FBQ0YsRUFBRSxFQUFHO1lBQ3ZERSxDQUFDLENBQUNELEVBQUUsR0FBR0w7UUFDVDtRQUVBLGlFQUFpRTtRQUNoRUcsQ0FBQUEsR0FBR2QsQ0FBQyxHQUFHLFNBQVNrQixLQUFLO1lBQ3BCLHdFQUF3RTtZQUN4RSxJQUFJUCxHQUFHUSxJQUFJLEdBQ1BKLElBQUlELEdBQUdDLENBQUMsRUFBRUMsSUFBSUYsR0FBR0UsQ0FBQyxFQUFFQyxJQUFJSCxHQUFHUixDQUFDO1lBQ2hDLE1BQU9ZLFFBQVM7Z0JBQ2RQLElBQUlNLENBQUMsQ0FBQ0YsSUFBSWhDLE9BQVFnQyxJQUFJLEVBQUc7Z0JBQ3pCSSxJQUFJQSxJQUFJNUMsUUFBUTBDLENBQUMsQ0FBQ2xDLE9BQVEsQ0FBQ2tDLENBQUMsQ0FBQ0YsRUFBRSxHQUFHRSxDQUFDLENBQUNELElBQUlqQyxPQUFRaUMsSUFBSUwsRUFBRyxJQUFLTSxDQUFBQSxDQUFDLENBQUNELEVBQUUsR0FBR0wsQ0FBQUEsRUFBSTtZQUN6RTtZQUNBRyxHQUFHQyxDQUFDLEdBQUdBO1lBQUdELEdBQUdFLENBQUMsR0FBR0E7WUFDakIsT0FBT0c7UUFDUCxxRUFBcUU7UUFDckUsc0VBQXNFO1FBQ3RFLDJEQUEyRDtRQUM3RCxHQUFHNUM7SUFDTDtJQUVBLEVBQUU7SUFDRixTQUFTO0lBQ1QsMkRBQTJEO0lBQzNELEVBQUU7SUFDRixTQUFTbUMsS0FBS1UsQ0FBQyxFQUFFVCxDQUFDO1FBQ2hCQSxFQUFFSSxDQUFDLEdBQUdLLEVBQUVMLENBQUM7UUFDVEosRUFBRUssQ0FBQyxHQUFHSSxFQUFFSixDQUFDO1FBQ1RMLEVBQUVMLENBQUMsR0FBR2MsRUFBRWQsQ0FBQyxDQUFDZSxLQUFLO1FBQ2YsT0FBT1Y7SUFDVDs7SUFFQSxFQUFFO0lBQ0YsWUFBWTtJQUNaLHVEQUF1RDtJQUN2RCxFQUFFO0lBQ0YsU0FBU2xCLFFBQVE2QixHQUFHLEVBQUVDLEtBQUs7UUFDekIsSUFBSUMsU0FBUyxFQUFFLEVBQUVDLE1BQU8sT0FBT0gsS0FBTUk7UUFDckMsSUFBSUgsU0FBU0UsT0FBTyxVQUFVO1lBQzVCLElBQUtDLFFBQVFKLElBQUs7Z0JBQ2hCLElBQUk7b0JBQUVFLE9BQU9HLElBQUksQ0FBQ2xDLFFBQVE2QixHQUFHLENBQUNJLEtBQUssRUFBRUgsUUFBUTtnQkFBSyxFQUFFLE9BQU9LLEdBQUcsQ0FBQztZQUNqRTtRQUNGO1FBQ0EsT0FBUUosT0FBT1gsTUFBTSxHQUFHVyxTQUFTQyxPQUFPLFdBQVdILE1BQU1BLE1BQU07SUFDakU7SUFFQSxFQUFFO0lBQ0YsV0FBVztJQUNYLG1FQUFtRTtJQUNuRSx3RUFBd0U7SUFDeEUsRUFBRTtJQUNGLFNBQVM5QixPQUFPTixJQUFJLEVBQUVHLEdBQUc7UUFDdkIsSUFBSXdDLGFBQWEzQyxPQUFPLElBQUk0QyxPQUFPZCxJQUFJO1FBQ3ZDLE1BQU9BLElBQUlhLFdBQVdoQixNQUFNLENBQUU7WUFDNUJ4QixHQUFHLENBQUNOLE9BQU9pQyxFQUFFLEdBQ1hqQyxPQUFRLENBQUMrQyxTQUFTekMsR0FBRyxDQUFDTixPQUFPaUMsRUFBRSxHQUFHLEVBQUMsSUFBS2EsV0FBV0UsVUFBVSxDQUFDZjtRQUNsRTtRQUNBLE9BQU90QixTQUFTTDtJQUNsQjtJQUVBLEVBQUU7SUFDRixhQUFhO0lBQ2IseUVBQXlFO0lBQ3pFLHVCQUF1QjtJQUN2QixFQUFFO0lBQ0YsU0FBU007UUFDUCxJQUFJO1lBQ0YsSUFBSXFDO1lBQ0osSUFBSWhELGNBQWVnRCxDQUFBQSxNQUFNaEQsV0FBV2lELFdBQVcsR0FBRztnQkFDaEQsc0VBQXNFO2dCQUN0RUQsTUFBTUEsSUFBSXpEO1lBQ1osT0FBTztnQkFDTHlELE1BQU0sSUFBSUUsV0FBVzNEO2dCQUNwQkgsQ0FBQUEsT0FBTytELE1BQU0sSUFBSS9ELE9BQU9nRSxRQUFRLEVBQUVDLGVBQWUsQ0FBQ0w7WUFDckQ7WUFDQSxPQUFPdEMsU0FBU3NDO1FBQ2xCLEVBQUUsT0FBT0osR0FBRztZQUNWLElBQUlVLFVBQVVsRSxPQUFPbUUsU0FBUyxFQUMxQkMsVUFBVUYsV0FBV0EsUUFBUUUsT0FBTztZQUN4QyxPQUFPO2dCQUFDLENBQUMsSUFBSUM7Z0JBQU1yRTtnQkFBUW9FO2dCQUFTcEUsT0FBT3NFLE1BQU07Z0JBQUVoRCxTQUFTckI7YUFBTTtRQUNwRTtJQUNGO0lBRUEsRUFBRTtJQUNGLGFBQWE7SUFDYiw2Q0FBNkM7SUFDN0MsRUFBRTtJQUNGLFNBQVNxQixTQUFTaUQsQ0FBQztRQUNqQixPQUFPQyxPQUFPQyxZQUFZLENBQUNDLEtBQUssQ0FBQyxHQUFHSDtJQUN0QztJQUVBLEVBQUU7SUFDRiw4REFBOEQ7SUFDOUQsOERBQThEO0lBQzlELDZEQUE2RDtJQUM3RCw4REFBOEQ7SUFDOUQsa0JBQWtCO0lBQ2xCLEVBQUU7SUFDRm5ELE9BQU9sQixLQUFLeUUsTUFBTSxJQUFJMUU7SUFFdEIsRUFBRTtJQUNGLHNFQUFzRTtJQUN0RSxxQkFBcUI7SUFDckIsRUFBRTtJQUNGLElBQUksS0FBbUIsSUFBWTJFLE9BQU9DLE9BQU8sRUFBRTtRQUNqREQsT0FBT0MsT0FBTyxHQUFHaEU7UUFDakIsNkRBQTZEO1FBQzdELElBQUk7WUFDRkQsYUFBYWtFLG1CQUFPQSxDQUFDO1FBQ3ZCLEVBQUUsT0FBT0MsSUFBSSxDQUFDO0lBQ2hCLE9BQU8sSUFBSSxJQUEyQyxFQUFFO1FBQ3REQyxtQ0FBTztZQUFhLE9BQU9uRTtRQUFZLENBQUM7QUFBQSxrR0FBQztJQUMzQyxPQUFPLEVBR047QUFHRCxnREFBZ0Q7QUFDaEQsR0FHRSxzRUFGc0U7QUFDdEUsa0RBQWtEO0FBQ2pELE9BQU9xRSxTQUFTLGNBQWVBLE9BQU8sUUFDdkMsRUFBRSxFQUNGQyxLQUFRLHVEQUF1RCIsInNvdXJjZXMiOlsid2VicGFjazovL3lvZ2Fwb3NlcGVyZmVjdC8uL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL3NlZWRyYW5kb20uanM/NjQ0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuQ29weXJpZ2h0IDIwMTkgRGF2aWQgQmF1LlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbmEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG53aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG5kaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbnBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xudGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG5FWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbk1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cbklOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZXG5DTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULFxuVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcblNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4qL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgcG9vbCwgbWF0aCkge1xuLy9cbi8vIFRoZSBmb2xsb3dpbmcgY29uc3RhbnRzIGFyZSByZWxhdGVkIHRvIElFRUUgNzU0IGxpbWl0cy5cbi8vXG5cbnZhciB3aWR0aCA9IDI1NiwgICAgICAgIC8vIGVhY2ggUkM0IG91dHB1dCBpcyAwIDw9IHggPCAyNTZcbiAgICBjaHVua3MgPSA2LCAgICAgICAgIC8vIGF0IGxlYXN0IHNpeCBSQzQgb3V0cHV0cyBmb3IgZWFjaCBkb3VibGVcbiAgICBkaWdpdHMgPSA1MiwgICAgICAgIC8vIHRoZXJlIGFyZSA1MiBzaWduaWZpY2FudCBkaWdpdHMgaW4gYSBkb3VibGVcbiAgICBybmduYW1lID0gJ3JhbmRvbScsIC8vIHJuZ25hbWU6IG5hbWUgZm9yIE1hdGgucmFuZG9tIGFuZCBNYXRoLnNlZWRyYW5kb21cbiAgICBzdGFydGRlbm9tID0gbWF0aC5wb3cod2lkdGgsIGNodW5rcyksXG4gICAgc2lnbmlmaWNhbmNlID0gbWF0aC5wb3coMiwgZGlnaXRzKSxcbiAgICBvdmVyZmxvdyA9IHNpZ25pZmljYW5jZSAqIDIsXG4gICAgbWFzayA9IHdpZHRoIC0gMSxcbiAgICBub2RlY3J5cHRvOyAgICAgICAgIC8vIG5vZGUuanMgY3J5cHRvIG1vZHVsZSwgaW5pdGlhbGl6ZWQgYXQgdGhlIGJvdHRvbS5cblxuLy9cbi8vIHNlZWRyYW5kb20oKVxuLy8gVGhpcyBpcyB0aGUgc2VlZHJhbmRvbSBmdW5jdGlvbiBkZXNjcmliZWQgYWJvdmUuXG4vL1xuZnVuY3Rpb24gc2VlZHJhbmRvbShzZWVkLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIga2V5ID0gW107XG4gIG9wdGlvbnMgPSAob3B0aW9ucyA9PSB0cnVlKSA/IHsgZW50cm9weTogdHJ1ZSB9IDogKG9wdGlvbnMgfHwge30pO1xuXG4gIC8vIEZsYXR0ZW4gdGhlIHNlZWQgc3RyaW5nIG9yIGJ1aWxkIG9uZSBmcm9tIGxvY2FsIGVudHJvcHkgaWYgbmVlZGVkLlxuICB2YXIgc2hvcnRzZWVkID0gbWl4a2V5KGZsYXR0ZW4oXG4gICAgb3B0aW9ucy5lbnRyb3B5ID8gW3NlZWQsIHRvc3RyaW5nKHBvb2wpXSA6XG4gICAgKHNlZWQgPT0gbnVsbCkgPyBhdXRvc2VlZCgpIDogc2VlZCwgMyksIGtleSk7XG5cbiAgLy8gVXNlIHRoZSBzZWVkIHRvIGluaXRpYWxpemUgYW4gQVJDNCBnZW5lcmF0b3IuXG4gIHZhciBhcmM0ID0gbmV3IEFSQzQoa2V5KTtcblxuICAvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSByYW5kb20gZG91YmxlIGluIFswLCAxKSB0aGF0IGNvbnRhaW5zXG4gIC8vIHJhbmRvbW5lc3MgaW4gZXZlcnkgYml0IG9mIHRoZSBtYW50aXNzYSBvZiB0aGUgSUVFRSA3NTQgdmFsdWUuXG4gIHZhciBwcm5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSBhcmM0LmcoY2h1bmtzKSwgICAgICAgICAgICAgLy8gU3RhcnQgd2l0aCBhIG51bWVyYXRvciBuIDwgMiBeIDQ4XG4gICAgICAgIGQgPSBzdGFydGRlbm9tLCAgICAgICAgICAgICAgICAgLy8gICBhbmQgZGVub21pbmF0b3IgZCA9IDIgXiA0OC5cbiAgICAgICAgeCA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGFuZCBubyAnZXh0cmEgbGFzdCBieXRlJy5cbiAgICB3aGlsZSAobiA8IHNpZ25pZmljYW5jZSkgeyAgICAgICAgICAvLyBGaWxsIHVwIGFsbCBzaWduaWZpY2FudCBkaWdpdHMgYnlcbiAgICAgIG4gPSAobiArIHgpICogd2lkdGg7ICAgICAgICAgICAgICAvLyAgIHNoaWZ0aW5nIG51bWVyYXRvciBhbmRcbiAgICAgIGQgKj0gd2lkdGg7ICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGRlbm9taW5hdG9yIGFuZCBnZW5lcmF0aW5nIGFcbiAgICAgIHggPSBhcmM0LmcoMSk7ICAgICAgICAgICAgICAgICAgICAvLyAgIG5ldyBsZWFzdC1zaWduaWZpY2FudC1ieXRlLlxuICAgIH1cbiAgICB3aGlsZSAobiA+PSBvdmVyZmxvdykgeyAgICAgICAgICAgICAvLyBUbyBhdm9pZCByb3VuZGluZyB1cCwgYmVmb3JlIGFkZGluZ1xuICAgICAgbiAvPSAyOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgbGFzdCBieXRlLCBzaGlmdCBldmVyeXRoaW5nXG4gICAgICBkIC89IDI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICByaWdodCB1c2luZyBpbnRlZ2VyIG1hdGggdW50aWxcbiAgICAgIHggPj4+PSAxOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHdlIGhhdmUgZXhhY3RseSB0aGUgZGVzaXJlZCBiaXRzLlxuICAgIH1cbiAgICByZXR1cm4gKG4gKyB4KSAvIGQ7ICAgICAgICAgICAgICAgICAvLyBGb3JtIHRoZSBudW1iZXIgd2l0aGluIFswLCAxKS5cbiAgfTtcblxuICBwcm5nLmludDMyID0gZnVuY3Rpb24oKSB7IHJldHVybiBhcmM0LmcoNCkgfCAwOyB9XG4gIHBybmcucXVpY2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGFyYzQuZyg0KSAvIDB4MTAwMDAwMDAwOyB9XG4gIHBybmcuZG91YmxlID0gcHJuZztcblxuICAvLyBNaXggdGhlIHJhbmRvbW5lc3MgaW50byBhY2N1bXVsYXRlZCBlbnRyb3B5LlxuICBtaXhrZXkodG9zdHJpbmcoYXJjNC5TKSwgcG9vbCk7XG5cbiAgLy8gQ2FsbGluZyBjb252ZW50aW9uOiB3aGF0IHRvIHJldHVybiBhcyBhIGZ1bmN0aW9uIG9mIHBybmcsIHNlZWQsIGlzX21hdGguXG4gIHJldHVybiAob3B0aW9ucy5wYXNzIHx8IGNhbGxiYWNrIHx8XG4gICAgICBmdW5jdGlvbihwcm5nLCBzZWVkLCBpc19tYXRoX2NhbGwsIHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgIC8vIExvYWQgdGhlIGFyYzQgc3RhdGUgZnJvbSB0aGUgZ2l2ZW4gc3RhdGUgaWYgaXQgaGFzIGFuIFMgYXJyYXkuXG4gICAgICAgICAgaWYgKHN0YXRlLlMpIHsgY29weShzdGF0ZSwgYXJjNCk7IH1cbiAgICAgICAgICAvLyBPbmx5IHByb3ZpZGUgdGhlIC5zdGF0ZSBtZXRob2QgaWYgcmVxdWVzdGVkIHZpYSBvcHRpb25zLnN0YXRlLlxuICAgICAgICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoYXJjNCwge30pOyB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBjYWxsZWQgYXMgYSBtZXRob2Qgb2YgTWF0aCAoTWF0aC5zZWVkcmFuZG9tKCkpLCBtdXRhdGVcbiAgICAgICAgLy8gTWF0aC5yYW5kb20gYmVjYXVzZSB0aGF0IGlzIGhvdyBzZWVkcmFuZG9tLmpzIGhhcyB3b3JrZWQgc2luY2UgdjEuMC5cbiAgICAgICAgaWYgKGlzX21hdGhfY2FsbCkgeyBtYXRoW3JuZ25hbWVdID0gcHJuZzsgcmV0dXJuIHNlZWQ7IH1cblxuICAgICAgICAvLyBPdGhlcndpc2UsIGl0IGlzIGEgbmV3ZXIgY2FsbGluZyBjb252ZW50aW9uLCBzbyByZXR1cm4gdGhlXG4gICAgICAgIC8vIHBybmcgZGlyZWN0bHkuXG4gICAgICAgIGVsc2UgcmV0dXJuIHBybmc7XG4gICAgICB9KShcbiAgcHJuZyxcbiAgc2hvcnRzZWVkLFxuICAnZ2xvYmFsJyBpbiBvcHRpb25zID8gb3B0aW9ucy5nbG9iYWwgOiAodGhpcyA9PSBtYXRoKSxcbiAgb3B0aW9ucy5zdGF0ZSk7XG59XG5cbi8vXG4vLyBBUkM0XG4vL1xuLy8gQW4gQVJDNCBpbXBsZW1lbnRhdGlvbi4gIFRoZSBjb25zdHJ1Y3RvciB0YWtlcyBhIGtleSBpbiB0aGUgZm9ybSBvZlxuLy8gYW4gYXJyYXkgb2YgYXQgbW9zdCAod2lkdGgpIGludGVnZXJzIHRoYXQgc2hvdWxkIGJlIDAgPD0geCA8ICh3aWR0aCkuXG4vL1xuLy8gVGhlIGcoY291bnQpIG1ldGhvZCByZXR1cm5zIGEgcHNldWRvcmFuZG9tIGludGVnZXIgdGhhdCBjb25jYXRlbmF0ZXNcbi8vIHRoZSBuZXh0IChjb3VudCkgb3V0cHV0cyBmcm9tIEFSQzQuICBJdHMgcmV0dXJuIHZhbHVlIGlzIGEgbnVtYmVyIHhcbi8vIHRoYXQgaXMgaW4gdGhlIHJhbmdlIDAgPD0geCA8ICh3aWR0aCBeIGNvdW50KS5cbi8vXG5mdW5jdGlvbiBBUkM0KGtleSkge1xuICB2YXIgdCwga2V5bGVuID0ga2V5Lmxlbmd0aCxcbiAgICAgIG1lID0gdGhpcywgaSA9IDAsIGogPSBtZS5pID0gbWUuaiA9IDAsIHMgPSBtZS5TID0gW107XG5cbiAgLy8gVGhlIGVtcHR5IGtleSBbXSBpcyB0cmVhdGVkIGFzIFswXS5cbiAgaWYgKCFrZXlsZW4pIHsga2V5ID0gW2tleWxlbisrXTsgfVxuXG4gIC8vIFNldCB1cCBTIHVzaW5nIHRoZSBzdGFuZGFyZCBrZXkgc2NoZWR1bGluZyBhbGdvcml0aG0uXG4gIHdoaWxlIChpIDwgd2lkdGgpIHtcbiAgICBzW2ldID0gaSsrO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCB3aWR0aDsgaSsrKSB7XG4gICAgc1tpXSA9IHNbaiA9IG1hc2sgJiAoaiArIGtleVtpICUga2V5bGVuXSArICh0ID0gc1tpXSkpXTtcbiAgICBzW2pdID0gdDtcbiAgfVxuXG4gIC8vIFRoZSBcImdcIiBtZXRob2QgcmV0dXJucyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgYXMgb25lIG51bWJlci5cbiAgKG1lLmcgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIC8vIFVzaW5nIGluc3RhbmNlIG1lbWJlcnMgaW5zdGVhZCBvZiBjbG9zdXJlIHN0YXRlIG5lYXJseSBkb3VibGVzIHNwZWVkLlxuICAgIHZhciB0LCByID0gMCxcbiAgICAgICAgaSA9IG1lLmksIGogPSBtZS5qLCBzID0gbWUuUztcbiAgICB3aGlsZSAoY291bnQtLSkge1xuICAgICAgdCA9IHNbaSA9IG1hc2sgJiAoaSArIDEpXTtcbiAgICAgIHIgPSByICogd2lkdGggKyBzW21hc2sgJiAoKHNbaV0gPSBzW2ogPSBtYXNrICYgKGogKyB0KV0pICsgKHNbal0gPSB0KSldO1xuICAgIH1cbiAgICBtZS5pID0gaTsgbWUuaiA9IGo7XG4gICAgcmV0dXJuIHI7XG4gICAgLy8gRm9yIHJvYnVzdCB1bnByZWRpY3RhYmlsaXR5LCB0aGUgZnVuY3Rpb24gY2FsbCBiZWxvdyBhdXRvbWF0aWNhbGx5XG4gICAgLy8gZGlzY2FyZHMgYW4gaW5pdGlhbCBiYXRjaCBvZiB2YWx1ZXMuICBUaGlzIGlzIGNhbGxlZCBSQzQtZHJvcFsyNTZdLlxuICAgIC8vIFNlZSBodHRwOi8vZ29vZ2xlLmNvbS9zZWFyY2g/cT1yc2ErZmx1aHJlcityZXNwb25zZSZidG5JXG4gIH0pKHdpZHRoKTtcbn1cblxuLy9cbi8vIGNvcHkoKVxuLy8gQ29waWVzIGludGVybmFsIHN0YXRlIG9mIEFSQzQgdG8gb3IgZnJvbSBhIHBsYWluIG9iamVjdC5cbi8vXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC5pID0gZi5pO1xuICB0LmogPSBmLmo7XG4gIHQuUyA9IGYuUy5zbGljZSgpO1xuICByZXR1cm4gdDtcbn07XG5cbi8vXG4vLyBmbGF0dGVuKClcbi8vIENvbnZlcnRzIGFuIG9iamVjdCB0cmVlIHRvIG5lc3RlZCBhcnJheXMgb2Ygc3RyaW5ncy5cbi8vXG5mdW5jdGlvbiBmbGF0dGVuKG9iaiwgZGVwdGgpIHtcbiAgdmFyIHJlc3VsdCA9IFtdLCB0eXAgPSAodHlwZW9mIG9iaiksIHByb3A7XG4gIGlmIChkZXB0aCAmJiB0eXAgPT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKHByb3AgaW4gb2JqKSB7XG4gICAgICB0cnkgeyByZXN1bHQucHVzaChmbGF0dGVuKG9ialtwcm9wXSwgZGVwdGggLSAxKSk7IH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuICB9XG4gIHJldHVybiAocmVzdWx0Lmxlbmd0aCA/IHJlc3VsdCA6IHR5cCA9PSAnc3RyaW5nJyA/IG9iaiA6IG9iaiArICdcXDAnKTtcbn1cblxuLy9cbi8vIG1peGtleSgpXG4vLyBNaXhlcyBhIHN0cmluZyBzZWVkIGludG8gYSBrZXkgdGhhdCBpcyBhbiBhcnJheSBvZiBpbnRlZ2VycywgYW5kXG4vLyByZXR1cm5zIGEgc2hvcnRlbmVkIHN0cmluZyBzZWVkIHRoYXQgaXMgZXF1aXZhbGVudCB0byB0aGUgcmVzdWx0IGtleS5cbi8vXG5mdW5jdGlvbiBtaXhrZXkoc2VlZCwga2V5KSB7XG4gIHZhciBzdHJpbmdzZWVkID0gc2VlZCArICcnLCBzbWVhciwgaiA9IDA7XG4gIHdoaWxlIChqIDwgc3RyaW5nc2VlZC5sZW5ndGgpIHtcbiAgICBrZXlbbWFzayAmIGpdID1cbiAgICAgIG1hc2sgJiAoKHNtZWFyIF49IGtleVttYXNrICYgal0gKiAxOSkgKyBzdHJpbmdzZWVkLmNoYXJDb2RlQXQoaisrKSk7XG4gIH1cbiAgcmV0dXJuIHRvc3RyaW5nKGtleSk7XG59XG5cbi8vXG4vLyBhdXRvc2VlZCgpXG4vLyBSZXR1cm5zIGFuIG9iamVjdCBmb3IgYXV0b3NlZWRpbmcsIHVzaW5nIHdpbmRvdy5jcnlwdG8gYW5kIE5vZGUgY3J5cHRvXG4vLyBtb2R1bGUgaWYgYXZhaWxhYmxlLlxuLy9cbmZ1bmN0aW9uIGF1dG9zZWVkKCkge1xuICB0cnkge1xuICAgIHZhciBvdXQ7XG4gICAgaWYgKG5vZGVjcnlwdG8gJiYgKG91dCA9IG5vZGVjcnlwdG8ucmFuZG9tQnl0ZXMpKSB7XG4gICAgICAvLyBUaGUgdXNlIG9mICdvdXQnIHRvIHJlbWVtYmVyIHJhbmRvbUJ5dGVzIG1ha2VzIHRpZ2h0IG1pbmlmaWVkIGNvZGUuXG4gICAgICBvdXQgPSBvdXQod2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBuZXcgVWludDhBcnJheSh3aWR0aCk7XG4gICAgICAoZ2xvYmFsLmNyeXB0byB8fCBnbG9iYWwubXNDcnlwdG8pLmdldFJhbmRvbVZhbHVlcyhvdXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9zdHJpbmcob3V0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciBicm93c2VyID0gZ2xvYmFsLm5hdmlnYXRvcixcbiAgICAgICAgcGx1Z2lucyA9IGJyb3dzZXIgJiYgYnJvd3Nlci5wbHVnaW5zO1xuICAgIHJldHVybiBbK25ldyBEYXRlLCBnbG9iYWwsIHBsdWdpbnMsIGdsb2JhbC5zY3JlZW4sIHRvc3RyaW5nKHBvb2wpXTtcbiAgfVxufVxuXG4vL1xuLy8gdG9zdHJpbmcoKVxuLy8gQ29udmVydHMgYW4gYXJyYXkgb2YgY2hhcmNvZGVzIHRvIGEgc3RyaW5nXG4vL1xuZnVuY3Rpb24gdG9zdHJpbmcoYSkge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSgwLCBhKTtcbn1cblxuLy9cbi8vIFdoZW4gc2VlZHJhbmRvbS5qcyBpcyBsb2FkZWQsIHdlIGltbWVkaWF0ZWx5IG1peCBhIGZldyBiaXRzXG4vLyBmcm9tIHRoZSBidWlsdC1pbiBSTkcgaW50byB0aGUgZW50cm9weSBwb29sLiAgQmVjYXVzZSB3ZSBkb1xuLy8gbm90IHdhbnQgdG8gaW50ZXJmZXJlIHdpdGggZGV0ZXJtaW5pc3RpYyBQUk5HIHN0YXRlIGxhdGVyLFxuLy8gc2VlZHJhbmRvbSB3aWxsIG5vdCBjYWxsIG1hdGgucmFuZG9tIG9uIGl0cyBvd24gYWdhaW4gYWZ0ZXJcbi8vIGluaXRpYWxpemF0aW9uLlxuLy9cbm1peGtleShtYXRoLnJhbmRvbSgpLCBwb29sKTtcblxuLy9cbi8vIE5vZGVqcyBhbmQgQU1EIHN1cHBvcnQ6IGV4cG9ydCB0aGUgaW1wbGVtZW50YXRpb24gYXMgYSBtb2R1bGUgdXNpbmdcbi8vIGVpdGhlciBjb252ZW50aW9uLlxuLy9cbmlmICgodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBzZWVkcmFuZG9tO1xuICAvLyBXaGVuIGluIG5vZGUuanMsIHRyeSB1c2luZyBjcnlwdG8gcGFja2FnZSBmb3IgYXV0b3NlZWRpbmcuXG4gIHRyeSB7XG4gICAgbm9kZWNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuICB9IGNhdGNoIChleCkge31cbn0gZWxzZSBpZiAoKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBzZWVkcmFuZG9tOyB9KTtcbn0gZWxzZSB7XG4gIC8vIFdoZW4gaW5jbHVkZWQgYXMgYSBwbGFpbiBzY3JpcHQsIHNldCB1cCBNYXRoLnNlZWRyYW5kb20gZ2xvYmFsLlxuICBtYXRoWydzZWVkJyArIHJuZ25hbWVdID0gc2VlZHJhbmRvbTtcbn1cblxuXG4vLyBFbmQgYW5vbnltb3VzIHNjb3BlLCBhbmQgcGFzcyBpbml0aWFsIHZhbHVlcy5cbn0pKFxuICAvLyBnbG9iYWw6IGBzZWxmYCBpbiBicm93c2VycyAoaW5jbHVkaW5nIHN0cmljdCBtb2RlIGFuZCB3ZWIgd29ya2VycyksXG4gIC8vIG90aGVyd2lzZSBgdGhpc2AgaW4gTm9kZSBhbmQgb3RoZXIgZW52aXJvbm1lbnRzXG4gICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpID8gc2VsZiA6IHRoaXMsXG4gIFtdLCAgICAgLy8gcG9vbDogZW50cm9weSBwb29sIHN0YXJ0cyBlbXB0eVxuICBNYXRoICAgIC8vIG1hdGg6IHBhY2thZ2UgY29udGFpbmluZyByYW5kb20sIHBvdywgYW5kIHNlZWRyYW5kb21cbik7XG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwicG9vbCIsIm1hdGgiLCJ3aWR0aCIsImNodW5rcyIsImRpZ2l0cyIsInJuZ25hbWUiLCJzdGFydGRlbm9tIiwicG93Iiwic2lnbmlmaWNhbmNlIiwib3ZlcmZsb3ciLCJtYXNrIiwibm9kZWNyeXB0byIsInNlZWRyYW5kb20iLCJzZWVkIiwib3B0aW9ucyIsImNhbGxiYWNrIiwia2V5IiwiZW50cm9weSIsInNob3J0c2VlZCIsIm1peGtleSIsImZsYXR0ZW4iLCJ0b3N0cmluZyIsImF1dG9zZWVkIiwiYXJjNCIsIkFSQzQiLCJwcm5nIiwibiIsImciLCJkIiwieCIsImludDMyIiwicXVpY2siLCJkb3VibGUiLCJTIiwicGFzcyIsImlzX21hdGhfY2FsbCIsInN0YXRlIiwiY29weSIsInQiLCJrZXlsZW4iLCJsZW5ndGgiLCJtZSIsImkiLCJqIiwicyIsImNvdW50IiwiciIsImYiLCJzbGljZSIsIm9iaiIsImRlcHRoIiwicmVzdWx0IiwidHlwIiwicHJvcCIsInB1c2giLCJlIiwic3RyaW5nc2VlZCIsInNtZWFyIiwiY2hhckNvZGVBdCIsIm91dCIsInJhbmRvbUJ5dGVzIiwiVWludDhBcnJheSIsImNyeXB0byIsIm1zQ3J5cHRvIiwiZ2V0UmFuZG9tVmFsdWVzIiwiYnJvd3NlciIsIm5hdmlnYXRvciIsInBsdWdpbnMiLCJEYXRlIiwic2NyZWVuIiwiYSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImFwcGx5IiwicmFuZG9tIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiLCJleCIsImRlZmluZSIsImFtZCIsInNlbGYiLCJNYXRoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/seedrandom/seedrandom.js\n");

/***/ })

};
;